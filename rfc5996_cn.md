# RFC 5996 - 互联网密钥交换协议第二版 （IKEv2）

## 摘要

本文用以详述互联网密钥交换协议第二版（IKEv2）。IKE是IPSec协议族的一部分，用以提供相互认证以及安全联盟（SAs）的建立与维护。本文基于RFC 4306更新，并包含所有来自RFC 4718的阐述。

## 目录

[TOC]

## 1. 引言

IP安全（IPSec）为IP数据报提供机密性，完整性，访问控制以及数据源认证。这些服务是通过在IP数据报的源和目的之间维护共享的状态提供的。这些共享的状态包括但不限于：IP数据报承载的服务类型，提供加密服务的加密算法以及加密算法需要的密钥。

通过手动的方式来指定这些共享状态无法实现良好的扩展性。因此，需要有一种协议来动态协商这些共享状态。本文既用以描述这种协议——互联网密钥交换协议（IKE）。IKE的第一个版本在RFCs 2407[DOI]，2408[ISAKMP]和2409[IKEv1]中定义。IKEv2用以替代所有这些定义，它原本在RFC 4306中定义并在RFC 4718中阐明，而本文用以提到和更新这两者。IKEv2是不具有向前兼容性的。本文不仅对IKEv2的定义进行阐明，同时也列出了相比之前版本的变化。在1.7节中列出了RFC 4306和本文的一些显著差别。

IKE在两个通信节点之间提供了相互认证，并建立起IKE的安全联盟（SA），IKE SA包含用以有效协商ESP（Encapsulating Security Payload） SA和AH（Authentication Header） SA所需要的机密信息和加密算法。本文中，术语“套件”或“加密套件”意为一组完整的用于保护SA的算法集合。协商的发起方会通过列出所有其支持的算法，这些算法之间可以混合组合，形成一个或多个加密套件。IKE亦可为IPSec或AH SA协商使用IP压缩（IPComp）。通过IKE SA保护建立起的ESP或AH SAs被称为“子SA”（Child SAs）。

所有的IKE交互由消息对组成：请求和回复。此消息对成为IKE“交换”，有时也被称为“请求/回复对”。开始用以建立新的IKE SA的交换是IKE_SA_INIT和IKE_AUTH；后续的交换有CREATE_CHILD_SA或INFORMATIONAL。通常情况下，一个IKE_SA_INIT交换和一个IKE_AUTH交换几个完成IKE SA和第一个子SA的建立。有些例外情况下，可能需要更多此类交换。但在任何情况下，IKE_SA_INIT交换必须在任何其他类型的交换之前完成，随后是IKE_AUTH交换，再之后，可能会有任何数量的CREATE_CHILD_SA交换或INFORMATIONAL交换。某些情况下，两个IPSec通信节点之间只需要一个子SA，那就无需多余的交换。后续交换一般发生在同一对通信对待他之间有额外的子SA的情况，也会用于一些IKE清理或维护功能。

一个IKE消息流一定由请求和回复组成。请求方有责任保证通信的可靠性。如果在超时间隔内没有收到回复，请求方有必要重传请求（或者放弃连接）。

IKE会话的第一个交换，即IKE_SA_INIT，用以协商IKE SA的安全参数，和DH值。

IKE会话的第二个交换，即IKE_AUTH，用以传输身份信息，证明对双方身份信息有秘密的可知性，建立第一个AH SA(通常也是唯一一个)或ESP SA（亦有可能建立子SA失败，但IKE SA依然会建立）。

后续的交换有CREATE_CHILD_SA（用以建立子SA）和INFORMATIONAL（删除SA，报告错误或其他清理维护信息）。每一个请求都需要回复。通常如果一个没有载荷的INFORMATIONAL（不是有加密载荷但大小为0）用于存活检测。所有这些后续的交换一定要在IKE初始交换完成后才可使用。

本章节后续的描述皆假设没有错误发生。在章节2.21中会描述错误控制。

### 1.1. 应用场景

IKE用于在几种不通场景下的ESP/AH SA的协商，每种场景都有其特殊的要求。

#### 1.1.1. 安全网关之间的隧道模式

               +-+-+-+-+-+            +-+-+-+-+-+
               |         | IPsec      |         |
    被保护     |隧道     | 隧道       |隧道     |     被保护
    子网   <-->|端点     |<---------->|端点     |<--> 子网
               |         |            |         |
               +-+-+-+-+-+            +-+-+-+-+-+
    
    图1：安全网关隧道

这种场景下，IP通信的端点上都没有部署IPSec，但是他们之间的网络节点会在部分路径实现安全保护。这种保护对于通信断点来说是透明的，并且取决于将流量送到隧道端点的路由。每个隧道端点都会宣告给对方处于它“后面”的被保护的子网地址，数据包被以隧道模式发送，隧道的内层IP头会包含实际通信点的IP地址。

#### 1.1.2. 通信端点之间的传输模式

    +-+-+-+-+-+                                          +-+-+-+-+-+
    |         |                 IPsec传输模式            |         |
    |被保护   |                 或隧道模式SA             |被保护   |
    |端点     |<---------------------------------------->|端点     |
    |         |                                          |         |
    +-+-+-+-+-+                                          +-+-+-+-+-+
    
    图2：通信端点直接对话

这种场景下，通信端点双方都按照[IPSECARCH]的要求部署了IPSec。传输模式中无需使用双层IP头。单独一对地址被用于协商保护流量的SA。这些通信端点可能会使用基于IPSec身份认证的应用层访问控制。此种部署使得点到点的安全成为可能，参见[ARCHPRINC][TRANSPARENCY][ARCHGUIDEPHIL]。在IPv4互联网环境下这种场景的或许没有适用性，但是在内联网环境下，IKEv1已经有了成功部署的先例。或许在向IPv6的演进过程中，IKEv2的此类部署会大量实现。

可能这种场景的通信端点的一端或两端都处于NAT后面，那么IPSec的流量将会需要UDP封装，通多UPD的端口号可以很好的区分正确的通信端点（参见章节2.23）.

#### 1.1.3. 通信端点到安全网关的隧道模式

    +-+-+-+-+-+                          +-+-+-+-+-+
    |         |         IPsec            |         |     被保护
    |被保护   |         隧道             |隧道     |     子网
    |端点     |<------------------------>|端点     |<--- 和/或
    |         |                          |         |     互联网
    +-+-+-+-+-+                          +-+-+-+-+-+

    图3：通信端点到安全网关隧道

这种场景下，一个受保护的通信端点通过IPSec隧道连接到集团网络。该通信端点可能使用通过此隧道访问集团内部资源，也有可能会将所有流量都发到集团网络，有集团的防火墙再进行下一步处理。无论哪种情况，该通信端点都会想要从安全网关分配到一个关联IP地址，以保证返回流量能正确的发往IPSec隧道。此IP可以静态指定或由网关动态分配。为了支持动态地址分配，IKEv2引入了一种的机制，通过“配置载荷”（configuration payloads）使得发起方可以向安全网关请求一个后者拥有的IP地址，在SA的有效期内使用。

这种场景下数据包会通过隧道模式传输。每一个来自被保护端点的数据报，外层IP源地址是其位置相关的（通常是它的可路由公网地址），而内层IP源地址则来自于安全网关分配（该地址使得发往该受保护端点的返回流量能被安全网关正确的送入IPSec隧道）。外层IP目的地址一定是安全网关的地址，而内层IP目的地址是数据的的最终目的地。

被保护端点在这种场景下也有可能位于NAT后。那么安全网关看到的外层源地址会与被保护端点发出的源地址不同，数据包需要通过UDP封装以保证正确路由。跟NAT相关的交互会在章节2.23进行详细讨论。

#### 1.1.4. 其他场景

也有可能出现其他的场景，或许是上述场景的嵌套。一个值得注意的例子是1.1.1和1.1.3的混合。一个子网可能会使用IPSec经由安全网关与外部通信，反之这个子网的地址也只能经由安全网关访问。例如，某人的家庭网络可以可以“虚拟”地通过一些静态IP访问，而其实ISP只是动态的将一些地址分配给了该用户的安全网关（那些静态IP和IPSec转发由位于其他地方的第三方提供）。

### 1.2. 初始交换

IKE通信以IKE_SA_INIT交换和IKE_AUTH交换开始（在IKEv1中被称为阶段1（Phase 1））。该初始交换通常由四个消息组成，有时也会有更多数量的消息。所有的IKE通信都由请求/回复对组成。我们首先将描述典型交换过程，然后再描述一些特殊情形。初始交换（IKE_SA_INIT）会协商加密算法，交换onoces并进行DH交换。

第二对交换（IKE_AUTH）对之前的消息进行认证，交换身份信息和证书并建立第一个子SA。这些消息的一部分是被由IKE_SA_INIT协商形成的密钥加密处理的，并会被完整性校验，因而攻击者无法获取这些身份信息，所有信息字段都是经过认证的。章节2.14将会描述加密密钥是如何被创建的。（中间人攻击者虽然无法完成IKE_AUTH交换，但是能获取发起者的身份信息。）

初始交换之后的消息都是经由在IKE_SA_INIT交换中协商的加密算法和密钥加密处理的。这些后续消息加密部分的语法将在章节3.14中描述，利用派生密钥的机制将在章节2.14描述。所有的后续消息都包含的一个加密载荷，尽管有时加密的内容为“空”。对于CREATE_CHILD_SA交换，IKE_AUTH交换或是INFORMATIONAL交换，当中紧跟消息头部的部分都是加密的并且使用了IKE SA中协商好的算法进行完整性校验。

每一封IKE消息在其头部都包含一个消息ID。该消息ID用以区分和匹配IKE的请求和回复，或以区分重传的消息。

在之后的描述当中，消息中的载荷类型和名称按下表对应。

    标记        载荷
    -----------------------------------------
    AUTH        认证
    CERT        证书
    CERTREQ     证书请求
    CP          配置
    D           删除
    EAP         可扩展认证
    HDR         IKE头部（不包含任何载荷）
    IDi         身份信息 - 发起方
    IDr         身份信息 - 响应方
    KE          密钥交换
    Ni, Nr      随机数（Nonce）
    N           通知
    SA          安全联盟
    SK          经过加密且被认证的
    TSi         流量选择器 - 发起方
    TSr         流量选择器 - 响应方
    V           厂商标识

每种载荷的具体内容将在章节3中描述。可选载荷类型将以中括号标识，形如[CERTREQ]；这表示证书请求载荷是可选的。

初始交换归纳如下：

    发起方                                                     响应方
    ----------------------------------------------------------------
    HDR, SAi1, KEi, Ni  -->

HDR包含了安全参数索引（SPIs），版本号，还有不通类型的标志位。SAi载荷声明了发起方为IKE SA支持的加密算法组合。KE载荷包含发起方的DH值.Ni是发起方的nonce。

    发起方                                                     响应方
    ----------------------------------------------------------------
                                  <--  HDR, SAr1, KEr, Nr, [CERTREQ]

响应方在发起方提供的加密算法列表中选择一组，并将其置于SAr1中作为选择确认，利用KEr（和接收到KEi）完成DH交换，也将其nouce置于Nr载荷。

完成第一对消息的交互之后，双方都能生成SKEYSEED，而通过SKEYSEED能推导出该IKE SA所需的所有密钥。接下来的消息都是被整体加密和认证的，IKE头部除外。由SKEYSEED推导出来的密钥有SK_e（加密）和SK_a（认证，亦即完整性保护）；章节2.13和2.14将会对密码推导过程进行详细描述。在通信的两个方向会分别计算独立的SK_e和SK_a。除了为了保护IKE SA而从DH值推导出的SK_e和SK_a之外，SK_d也会被推导，其将作用于推导子SAs密钥的材料。SK { ... }的格式表面该消息是经由与传输方向相关的SK_e和SK_a加密和认证的。

    发起方                                                     响应方
    ----------------------------------------------------------------
    HDR, SK {IDi, [CERT,] [CERTREQ,]
       [IDr,] AUTH, SAi2,
       TSi, TSr}  -->

发起方将自己的身份信息置入IDi载荷，证明其有对于IDi相关秘密的可知性，同时利用AUTH载荷验证第一条消息内容（参将章节2.15）。发起方有可能通过CERT载荷发送其证书，通过CERTREQ发送该证书的信任链起点（根证书???）。一旦发送了使用了CERT载荷，当中的第一张证书必须包含验证AUTH字段的公钥。

可选载荷IDr使得发起方可以指定其期望通信的对端。这在响应方使用单个IP为多个身份提供服务时有用。如何响应方不接受发起方提供的IDr信息，响应方可能使用其他的IDr完成交换。如果发起方不允许对方使用与所发IDr不同的身份信息，它可以选择在通知对方后关闭该SA。

流量选择器（TSi和TSr）将在章节2.9讨论。

发起方同时会利用SAi2载荷开始子SA的协商。最后一部分载荷具体内容（以SAi2开始）在描述CREATE_CHILD_SA交换时再做详细探讨。

    发起方                                                     响应方
    ----------------------------------------------------------------
                                    <--  HDR, SK {IDr, [CERT,] AUTH,

响应方将其身份信息置入IDr载荷，可选地发生一张或多张证书（同样，第一张证书需要包含验证AUTH载荷的公钥），利用AUTH载荷完成身份认证并对第二条消息进行完整性校验，使用最后部分载荷完成子SA的协商。

IKE通信双方在IKE_AUTH交换过程中必须对所有的签名和消息认证码（MACs）进行校验。如果有任何一方使用了共享密钥的认证方式，那么ID载荷中的名称必须与生成AUTH载荷的密钥相关。

由于发起方在IKE_SA_INIT交换就发送了DH值，因此它必须从它支持的DH组当中“猜出”响应方可能支持的那一组。如果发起方猜错了，响应方会以一个INVALID_KE_PAYLOAD类型的通知载荷指明正确的DH组。这种情况下，发起方必须已纠正后的DH组重传IKE_SA_INIT交换消息。发起方必须再次发送完整的算法支持列表，因为直接的拒绝通知是未经认证的，若存在中间人攻击，其有可能致使原始的通信双方协商为安全性较低的加密算法——而原本双方都倾向于使用安全性较高的加密算法。

如果在IKE_AUTH的交换中，子SA的协商由于某些原因失败了，IKE SA应当正常协商完成。IKE_AUTH交换过程中，导致IKE SA协商的消息类型包括：NO_PROPOSAL_CHOSEN，TS_UNACCEPTABLE，SINGLE_PAIR_REQUIRED，INTERNAL_ADDRESS_FAILURE，和 FAILED_CP_REQUIRED。

如果协商失败与创建IKE SA相关（例如对方返回AUTHENTICATION_FAILED错误通知），那么IKE SA不会成功协商。注意，尽管IKE_AUTH消息是被加密和认证的，如果此类消息的接收方还未完成对对端的认证（或者认证过程失败），该消息需要引起注意。进一步说，假设MAC验证通过了，该错误通知的发起方被识别为IKE_SA_INIT交换中的响应方，但是其身份依然无法被保证???。

注意IKE_AUTH消息中并未包含KEi/KEr或Ni/Nr载荷。因此，IKE_AUTH交换中的SA载荷中的类型4的变换式（DH组）的值只能为NONE。那么最终实现时应该直接忽略该变换式子结构。

### 1.3. CREATE_CHILD_SA交换

CREATE_CHILD_SA交换用来生成新的子SA，也用来重新协商（rekey）IKE SA和子SA。该交换由一对请求/回复组成，其部分功能可类比于IKEv1中的阶段2（Phase 2）.它可以由成功建立IKE SA的双方中的任意一方发起。

SA的rekey通过创建新的SA，随即删除旧的SA完成。本章节将描述rekey的第一部分，即创建新的SA；rekey的具体机制，包括将流量切换到新的SA再删除旧的SA，将在章节2.8讨论。推荐将这两部分内容一起阅读以便更好地理解rekey的流程。

任何一方都可以发起CREATE_CHILD_SA交换，所以在本章节术语发起者指代发起该交换的一方。具体实现时，某些IKE通信节点有可能会拒绝所有的CREATE_CHILD_SA请求。

CREATE_CHILD_SA请求有可能会包含KE载荷用于额外的DH交换以为子SA提供更高级别的前向安全保证。子SA的密钥生成函数需要的输入包括由创建IKE SA时协商的SK_d，CREATE_CHILD_SA交换时传输的nonce以及DH值（如果由KE载荷的话）。

如果CREATE_CHILD_SA交换使用了KEi载荷，那么SA中至少有一组加密算法需要包含KEi使用的DH组。KEi相关的DH组必须是发起方期望响应方接受的DH组中的一个（发起方可以提供多个DH组）。如果响应方选择了不同的DH组（NONE除外），响应方必须拒绝之前的请求并通过INVALID_KE_PAYLOAD通知发起方其期望的DH组。该通知消息中由两个8位数据：以从小到大的顺序列出可接受的DH组???。对于这种拒绝的请求，CREATE_CHILD_SA交换将会失败，发起方可能会以响应方提供的DH组和KEi重新发起协商。

响应方会回应NO_ADDITIONAL_SAS通知以表示由于其无法在当前IKE SA下接受更多子SA,CREATE_CHILD_SA请求被拒绝。此类通知亦可用于拒绝IKE rekey。某些最小实现可能只接受随IKE初始交换协商成功的子SA而拒绝任何其他的子SA创建请求。

#### 1.3.1. 通过CREATE_CHILD_SA创建新的子SA

子SA可通过CREATE_CHILD_SA请求开始建立。请求消息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR, SK {SA, Ni, [KEi],
       TSi, TSr}  -->

发起方将SA提议置入SA载荷，nonce置入Ni载荷，DH值置入可选的KEi载荷，此外将该SA相关的流量选择器置入TSi和TSr载荷。

建立新的子SA的CREATE_CHILD_SA回复消息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
                                        <--  HDR, SK {SA, Nr, [KEr],
                                                TSi, TSr}

响应方使用相同的消息ID进行回复，内容有SA载荷包含接受的SA提议，KEr载荷包含DH值（如果发起方提供了KEi，并且选择的加密算法组合中就对于的DH组）。

为子SA所承载流量定义的流量选择器将会在TSi/TSr载荷中发送，该值有可能是发起方选择的流量选择器的子集。

USE_TRANSPORT_MODE通知可能出现在子SA请求消息中。它用于通知对方该子SA倾向于使用传输模式而非隧道模式。如果响应方接受这类提议，它必须在回复消息中也包含USE_TRANSPORT_MODE通知。如果响应方拒绝这类提议，子SA将以隧道模式建立。如果发起方不接受这种变化，发起方必须删除该SA。注意，除了使用USE_TRANSPORT_MODE通知的情况，所有的子SA都默认使用隧道模式。

ESP_TFC_PADDING_NOT_SUPPORTED通知表明消息的发送方不支持在协商的子SA中传输包含流量保密（Traffic Flow Confidentiality）填充字段的数据包。如果通信双方都不支持TFC填充，在请求/回复中都会包含该类型通知。如果只有其中一方发送的消息包含次通知，那在零一方向上的流量仍能使用TFC填充。

NON_FIRST_FRAGMENTS_ALSO通知用于报文控制。更为详细的解释参见[IPSECARCH]。通信双方在发送非首报文之前必须先协商好是否支持该类型报文。只有在双方发送的消息中都包含该通知，此种行为才被允许。如果回复发不想接受或发送非收报文，它将直接忽略NON_FIRST_FRAGMENTS_ALSO通知，但不会拒绝子SA的建立。

IPCOMP_SUPPORTED通知将在章节2.22中讨论，其也有可能出现在CREATE_CHILD_SA交换中。

失败的子SA协商不应该影响到IKE SA：没有任何必要否认IKE SA的建立。章节2.21将列出建立子SA失败的相关错误信息。

#### 1.3.2. 通过CREATE_CHILD_SA交换rekey IKE SA

Rekey IKE SA使用的CREATE_CHILD_SA请求消息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR, SK {SA, Ni, KEi} -->

发起方将SA提议置入SA载荷，nouce置入Ni载荷，DH值置入KEi载荷。KEi载荷是必要的。新的发起方SPI（iCookie）会被置入SA载荷的SPI字段。一旦某一方收到或发出了IKE SA rekey请求，它就不应该在该SA上发起任何CREATE_CHILD_SA交换。

Rekey IKE SA使用的CREATE_CHILD_SA回复消息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
                                          <--  HDR, SK {SA, Nr, KEr}

响应方以相同的消息ID回复，消息中包含其接受的SA提议，DH值。新的响应方SPI（rCookie）也会置入SA载荷的SPI字段。

新的IKE SA会将消息ID重置为0。双方在IKE SA的第一封消息的消息ID为0.旧IKE SA会保留其编号状态，以保证该SA上的后续报文（例如IKE SA 删除报文）拥有连续的ID号。新IKE SA还会将其窗口重置为1，发起这次reky的一方将会成为该IKE SA上的新的“原始”发起方。

章节2.18对IKE SA的rekey有更消息的讨论。

#### 1.3.3. 通过CREATE_CHILD_SA交换rekey子SA

Rekey子SA使用的CREATE_CHILD_SA请求消息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR, SK {N(REKEY_SA), SA, Ni, [KEi],
       TSi, TSr}   -->

发起方将SA提议置入SA载荷，nonce置入Ni载荷，DH值置入可选的KEi载荷，将该SA相关的流量选择器置入TSi和TSr载荷。

章节1.3.1描述的各种通知载荷也同样适用于rekey交换。通常rekey使用的这些通知类型更该SA初始化时使用的保持不变。

REKEY_SA通知载荷必须包含在CREATE_CHILD_SA交换当中——如果该交换的目的是替换之前的ESP/AH SA。被rekey的SA以其SPI识别，该字段被置入REKEY_SA通知载荷中：该SPI是消息发送方预期在入方向上ESP/AH报文中携带的。该通知载荷不会附带任何实际数据。但在该载荷中有一协议ID字段，它被设置以匹配被rekey的SA所用的协议，例如ESP为3，AH为2.

Rekey子SA使用的CREATE_CHILD_SA回复消息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
                                        <--  HDR, SK {SA, Nr, [KEr],
                                                TSi, TSr}

响应方以相同的消息ID回复，消息中包含其接受的SA提议，DH值（如果请求消息中有KEi载荷的话）。

流量选择器也会在TS载荷中发送，它可能是发起方提出的TS的子集。

### 1.4. INFORMATIONAL交换

在IKE SA交互的不同阶段，通信节点可能需要通过一些控制信息向对方发送错误信息或特定通知。IKE定义了INFORMATIONAL交换来提供该功能。INFORMATIONAL交换必须在初始交换之后才能进行，这些消息都是经有协商好的密钥加密认证处理的。注意，有些交互信息——并非IKE交换——会在IKE语境之外发送，在章节2.21有针对这些信息的详尽描述。

适用于某个IKE SA的控制信息必须在该SA保护下发送。适用于某个子SA的控制信息也必须在其关联的IKE SA保护下发送（若IKE SA被rekey了，则使用rekey后的新IKE SA）。

INFORMATIONAL交换信息会包含0个或多个通知/删除/配置载荷。INFORMATIONAL交换的接受者必须发出某种形式的回复；否则，消息发起方会认为消息可能在网络中丢失而进行重传。回复的消息可以是空消息。INFORMATIONAL交换的请求消息也可能不带任何载荷。这种类型的消息通常用来验证对方的活跃性。

INFORMATIONAL交换信息如下：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR, SK {[N,] [D,]
       [CP,] ...}  -->
                                             <--  HDR, SK {[N,] [D,]
                                                     [CP], ...}

对INFORMATIONAL消息的处理取决于其所携带的载荷。

#### 1.4.1. 通过INFORMATIONAL交换删除SA

ESP/AH SA都是成对生成的，每个方向各一个SA。当某个SA关闭时，相关的一对SA都会关闭（即被删除）。每个通信节点必须关闭它入方向的SA，允许另一方关闭这对SA中的另一个。通过在INFORMATIONAL交换消息中附加一个或多个删除载荷，并在消息中列出需要删除的SPI（这些SPI会出现在所有如方向的数据包头部），可以对SA进行删除。消息的接收方必须关闭消息中指定的SA。如果需要同时删除多个SA，消息发送方将所有SA对中入方向的SPI加入的删除载荷当中一起发送。

一般情况下，INFORMATIONAL交换的回复消息会包含为SA对当中的另一半SPI进行删除的载荷。有一种例外，在偶然情况下，通信双方同时决定关闭相关的SA，双方（几乎）同时发出带删除载荷的INFORMATIONAL交换消息，这两封消息会同时穿过网络。如果通信节点接收到了针对它已经生成删除请求的SA的删除请求，它必须在生成删除请求时关闭出方向的SA，而在生成回复时删除入方向的SA。那种这种情况下最后生成的回复就一定不能包含关于已经删除的SA的删除载荷，否则会导致重复删除而删除掉错误的SA。???

与ESP/AH SA相似，IKE SA也是通过INFORMATIONAL交换删除。删除IKE SA的操作隐式的关闭所有在该SA保护下生成的子SA。对于IKE SA的删除请求的回复是空的INFORMATIONAL回复。

半关闭的ESP/AH连接是异常的，拥有审计功能的通信节点应该在持续出现半关闭的情况下进行审计。注意这种规范并没有固定的时间限制，这完全取决于独立的通信节点本身的超时设置。通信节点可能会拒绝所有在半关闭状态下入方向的流量，但它绝不能单方面的关闭并重用SPI。如果连接的状态完全错乱了，通信节点应该直接关闭IKE SA。它可以选择在新建的IKE SA基础上再重新协商独立的新的子SA。

### 1.5. IKE SA保护之外的消息

在某些情况下，通信节点可能会接受到它无法处理的IKE报文，但它希望能通知到对方这种状况。

+ 接收到携带无法识别的SPI的ESP/AH报文。这可能是由于接收节点最近崩溃了而失去了IKE状态信息，或由于其他系统错误和攻击。

+ 在500/4500端口接收到携带无法识别SPI的加密IKE请求报文。这可能是由于接收节点最近崩溃了而失去了IKE状态信息，或由于其他系统错误和攻击。

+ 接收到的IKE报文的IKE版本号大于本地能够支持的最高版本号。

在第一种情况下，如果接受节点有与报文源地址相关的活跃的IKE SA，它可以在该SA上针对这个报文回复对方一个携带INVALID_SPI通知的INFORMATIONAL交换消息。该通知的数据部分包含接收到的无效数据包的SPI。原始的数据发送接收到该通知之后，虽然其无法区分回复的SPI是用户AH还是ESP的，但这不重要，因为这个SPI本来就应该与这两者不通。如果接受节点并不存在合适的IKE SA，它可以直接明文回复信息给报文的源地址，如果是UDP报文的话还应该将原始的UDP源端口作为回复时的目的端口。这种情况下，这种信息对原始发送方来说，仅能作为通信出错的一种提示。这类信息不属于INFORMATIONAL交换，所以该消息的接收方不能回复它，否则会造成消息循环。它因这样组成：没有IKE SPI因为这对接收方来说没有任何意义；可以使用0或随机值填充报文（这恰好是章节3.1讨论的避免空IKE发起方SPI的一种例外）。该通知的发起方标志位置1，回复标志位置0，而版本号标志位遵循一般配置；这些标志位回在章节3.1描述。

对于第二种和第三种情况，回复消息都没有加密保护，要么携带INVALID_IKE_SPI通知，要么携带INVALID_MAJOR_VERSION通知（通知数据为空）。这些消息属于回复，所以会直接送往原始的源地址/源端口，并且复制原报文的IKE SPI，消息ID和交换类型。回复标志位置1，版本号标志位遵循一般配置。

### 1.6. 要求术语

本文出现的术语，其原始定义在[IPSECARCH]能找到。应该注意到IKEv2的部分实现依赖于某些定义在[IPSECARCH]中的处理流程，本文将会多次提及。

关键词“必须”，“必须不”，“要求”，“应该”，“不应该”，“推荐”，“可能”和“可选择地”依据[MUSTSHOULD]文档解读。

### 1.7. 本文与RFC 4306的主要区别

本文覆盖了关于IKEv2的详细阐述和扩展讨论。大部分阐述基于[Clarif]。文中列出的改变都是经过IPsec工作组讨论过的（在工作组解散后讨论继续于IPsec邮件组）。那份文档包含了IKEv2中不清晰内容的详尽解释，对IKEv2的开发实现有重大意义。

本文描述的协议保留了与RFC 4306相同的主要版本号（2）和小版本号（0）。版本号在RFC 4306以来并无变化。本文列出的为数不多的技术细节变化应当不会对遵循RFC 4306的实现有任何影响。

本文对图示和参考的处理较[IKEV2]更为连贯。

IKEv2开发者已经注意到RFC 4306中“应该”级别的要求经常不够清晰，不知道何时不满足要求也是可行的。他们也注意到某些“必须”级别的要求与互操作性无关。本文对这些要求做了更清晰的阐述。非大写的“应该”和“必须”以词义理解，无需遵从[MUSTSHOULD]解读。

IKEv2（和IKEv1）的开发者注意到在RFC 4306的章节3.10.1中，有相当客观的代码材料。这导致开发者无法获取文档正中所需的信息。那些表中的大量材料已经被移到文档正文相关的附件部分。

本文移除了AH/ESP嵌套的讨论。由于完成RFC 4306和RFC 4301中出现了一些时差，RFC 4306中出现了一个错误。基本上IKEv2基于RFC 4301，它并没有术语RFC 2401部分的“SA bundles”。一个数据包可以被IPSec多次处理，每一次处理使用独立的SA，处理序列由一张转发表定义。在IKEv2中，这些SA中的每一个都必须由独立的CREATE_CHILD_SA交换创建。

本文移除了INTERNAL_ADDRESS_EXPIRY配置属性的讨论，因为它的实现有相当大的问题。遵循本文的实现必须胡写包含类型5的提议——INTERNAL_ADDRESS_EXPIRY的旧值。本文还移除了INTERNAL_IP6_NBNS配置属性。

本文移除了对含错续载荷的消息拒绝的可行性；新的实现必须不拒绝这些消息。这是由对载荷次序描述不够清晰造成的。

RFC 4306中的内容列表最终在IANA注册时，只包含了RFC 4306中明确定义的。开发者应当注意有些新的内容在RFC 4306发表后加入到了IANA。

本文加入了通知信息何时以加密形式发送，何时没有加密发送的解释。

本文对如何协商混合模式加密套件由更多的讨论。

略。。。

## 2. IKE协议细节和变化

IKE报文通常在UDP 500端口上发送和接收，有时也以不通的格式在UDP 4500端口发送接收。由于UDP是不可靠的协议，IKE包含了纠正传输错误的机制，这些错误包括丢包，数据包重放和数据包伪造。IKE被设计成在下列情况下均能作用：（1）至少有一封报文在超时之前达到了目的地；（2）传输通道没有被伪造或重放的数据包填满以致使某一方通信节点的网络或CPU资源耗尽。即使没有那些最低性能要求，IKE也被设计为关闭的非常彻底（就像网络中断一样）。

尽管IKEv2报文是较短的，其承载的内容结构是没有上限的（特别是数字证书的数量），而且IKEv2本身并没有提供对大尺寸消息的分片机制。IP协议本省已经定义对过大的UDP报文的分布机制，然后最终实现时对消息大小的支持可能不同。此外，使用IP分片是的IKE通信节点有收到DoS攻击的风险[DOSUDPPROT]。最后，一些NAT或防火墙设备可能会禁止IP分片行为。

所有的IKEv2实现必须能够发送接受和处理最大1280 Byte的IKE消息，最好能够发送接受和处理最大3000 Byte的IKE消息。IKEv2实现需要知晓其节点支持的最大UDP报文尺寸，在消息大小超过该尺寸的情况下需要去除一部分证书或者加密算法提议以便减小报文尺寸。使用“Hash和URL”的格式替代直接包含证书可以有效的避免大部分问题。实现和配置需要时刻注意，如果证书URL查找只能在子SA建立后进行，这种递归情况会是使得该机制失效。

由UDP 4500端口发送的所有IKE消息，必须带有4个0的前缀，否者接收方将不知道如何处理该消息。

### 2.1. 重传定时器的使用

所以的IKE消息都是成对出现的，包看请求和回复。IKE SA的建立通常包含两个交换。一旦IKE SA建立成功，该SA的任何一方都可能随时发起某种请求，所以在某一是个可能有多个请求和回复处于“in flight”状态。但是每一条消息都会被标记上请求或者回复，而且每一个交换中，双方各自作为发起方和响应方。

每一对IKE消息，发起方负责超时情况下的重传。响应方绝对不能擅自发起回复消息的重传，只能等待发起方重传的请求消息。在这情况下，响应方必须忽略被重传的请求，除非它导致重传回复???。发起方必须保存每个请求，直到接收到回复。响应方必须保存每个回复，直到它收到一个序列号大于或等于该响应报文序列号加窗口值（参见章节2.3）的新的请求。为了节省内存，允许响应方在几分钟的超时设置后删除回复消息。如果响应方在这是接到到了一个重传的请求（而他已经删掉了之前的回复消息），它必须忽略该请求（而非试图组装新的回复消息）。

IKE时可靠的协议：发起方在没有收到回复时必须重传请求，否则就判定IKE SA有问题了。在后种情况下，发起方将丢弃所有跟该SA相关的状态信息，包括在该SA保护下建立的子SA的状态。发起方的重传消息必须与原始消息bit层面一致。这表示，从IKE头部开始（始于发起方SPI字段）后面的内容要完全一致；二者之前的部分内容可以有差异（如IP首部和UDP首部）。

对于IKE_SA_INIT请求的重传有些特殊处理。但接收方收到一份IKE_SA_INIT请求时，它需要判断这份请求是属于某个“半打开”状态的IKE SA（意味着响应方要重传一份回复消息）还是全新的（意味着响应方要生成新的IKE SA并发送全新的回复消息），抑或是属于一个IKE_AUTH请求消息都已经收到的IKE SA（那么响应方应该直接忽略它）。

响应方仅依靠发起方的SPI或者IP地址不足以判断出收到的IKE_SA_INIT的请求属于上述的那种情况，因为处于同一个NAT设备之后的不通的通信节点可以使用相同的发起方SPI。所以更合理的处理方式是，响应方检查整个数据包，消息的HASH或Ni载荷。

单向消息的重传策略与普通消息不同。因为单向消息中没有确认消息，没有理由毫无代价的重传信息。假设所有这类消息是错误通知，针对每一个“offending”包发送一次通知时很合理的，若再次收到offending的包，那么可以选择重传。尽管如此，应该对这种错误通知的重传加以限制。

### 2.2. 消息ID序列号的使用

每一个IKE消息在头部都会包含消息ID。消息ID用来匹配请求和回复消息，并且识别消息是否属于重传。消息重传时必须使用跟原始消息一致的消息ID。

消息ID是一个32 bit长度的字段，有IKE_SA_INIT消息开始，编号为0（由回复消息含COOKIE或INVALID_KE_PAYLOAD载荷引起的重传，编号仍为0），随后逐一递增。因此，IKE_AUTH的消息将从ID 1开始，第二对IKE_AUTH消息（使用EAP的情况下）ID将为2，以此类推。在IKE SA rekey之后，在新的SA上，消息ID重置为0.

IKE SA的没个通信节点维护者两份“当前”消息ID：作为发起方将要发送的下一个请求时使用的ID，和作为响应方在接收到来自对方请求而生成回复时使用的ID。这些计数随着请求报文的接受和发送增加。回复消息使用和请求消息一直的消息ID。这就意味着，在初始交换之后，每一个计数n都有可能出现在4封不同的消息中：第n个原始IKE发起方发出的请求和其回复，第n个有响应方发出的请求消息和其回复。那么如果双方所发出的请求消息数量相差很大，那么两个方向上的消息ID也将会相差很大。这些有相同ID的消息很容易区分，因为在IKE头部还有发起方和响应方标识位设置。

本文自始至终将“发起方”定义为发起消息交换的那一方。而将“原始发送方”定义为建立起当前IKE SA时，发起协商的那一方。反过来讲，如果“原始响应方”开始rekey新的IKE SA，那么这一方将变成新IKE SA的“原始发送方”。

注意，消息ID是被加密保护并反重放攻击的。在极少数的情况下，消息ID太大了导致超出了32 bit的计数范围，此时必须强制关闭IKE SA或rekey。

### 2.3. 重复请求的窗口大小

若有一方使用了SET_WINDOW_SIZE载荷，则说明其可以保存多个并行协商状态，允许对方同时发送多个协商请求而无需等到接受回复后再进行。跟SET_WINDOW_SIZE相关的参数必须为4字节长，包含了发送方承诺保留消息的最大值。初始交换完成之前，窗口大小一直为1.

IKE通信节点在没有接收到对方的SET_WINDOW_SIZE通知的情况下，必须等到前一封消息的回复达到，才能发起下一封消息。SET_WINDOW_SIZE消息能够更大的利用网络吞吐。

在IKE SA建立起来之后，为了能够最大化利用网络带宽，IKE的通信节点可能会同时发出多个请求消息而无需等待回复达到，最大消息数受限于对方在SET_WINDOW_SIZE里宣告的数量。这些同时发出的请求有可能在到达对方时乱序。而IKE的通信节点必须随时准备接受和处理某一个乱序达到的报文以避免死锁。IKE通信节点可能还需要处理多个乱序消息的情况。

IKE通信节点一定不能发出超多对方宣告的窗口大小数量的消息。换句话说，如果响应方宣告的窗口大小时N，发起方将要发送消息X时，发起方必须等到它接收到了X-N之前所有报文的回复才能发送。IKE通信节点在收到某一请求消息的回复之前，必须保存该消息的一份副本（或者能精确识别它）。IKE通信节点要保存等同于乙方宣告窗口大小数量的回复报文的副本（或者能精确识别他们），这样如果某些回复消息在传输过程中丢包了，发起方发起请求重传时才能精确重传回复消息。

对于支持的窗口大小大于1的IKE通信节点，它应该有能力处理由网络中断和数据包乱序形成的非正常情况。

窗口大小通常是IKE实现的一项属性（可能是可配置的），它跟拥塞控制不相关（例如，不同于TCP协议中的窗口）。特别的，对于收到了一份包含比己方窗口大小值要小的SET_WINDOW_SIZE通知消息的接收方来说，目前并没有定义合适的处理机制。所以，没有办法减小一个活跃IKE SA的窗口大小；只能增加。在rekey IKE SA的时候，新IKE SA的窗口大小以1开始，直到通过发送新的SET_WINDOW_SIZE通知显式增加它。

INVALID_MESSAGE_ID通知消息用于通知对方接收到的IKE消息ID超出了接收方的接收窗口。该类型的通知消息载荷不能置于回复消息；且不可对对应的请求消息进行确认。接收方应当生成一份包含32位非法消息ID作为通知数据的INFORMATIONAL交换消息发送给非法消息的发送方。是否产生该类型的通知是可选的，必须对该类型的通知进行速率限制。

### 2.4. 状态同步和连接超时

IKE通信节点可以随时删除跟某一IKE SA相关的状态信息及其子SA的状态信息。这是为了应对任何通信节点崩溃或重启的情况出现。保证在某一方失败或重新初始化其状态时，另一方能够检测到这些变化而不会通过再已经丢弃的SA上继续发送数据包而使其陷入黑洞是非常重要的。

INITIAL_CONTACT通知用以表明该SA是当前认证节点之间唯一活跃的IKA SA。它可能由某一方在崩溃之后建立的IKE SA上发送，这样另一方可以利用该通知删除所有相关节点之间的其他SA而无需等待超时。可能出现重复情况的节点禁止发送该类型通知（例如，某些证书可用于漫游用户从不同的远程系统同时连接到企业防火墙）。INITIAL_CONTACT如果发送的话，必须放在第一对IKE_AUTH交换的请求或响应消息中，不允许放在之后的交换；接受方可以拒绝非第一对IKE_AUTH交换中出现的该类型通知。

由于IKE被设计成不受网络中DoS攻击的影响，通信节点不能通过路由层面的信息（如ICMP消息）或者未经过加密保护的IKE消息（例如有关无法识别的SPI的通知信息）来判定对方失败。只有在超时时间内多次重复的请求没有收到任何回复，或者在跟同一节点的不同SA上收到了INITIAL_CONTACT通知，才能判定对方失败。通信节点通过路由层面的信息应该怀疑对方可能失败了，接着发起探测对方是否存活的请求信息。IKE指定了使用空的INFORMATIONAL请求和其要求的回复消息（跟所有IKE请求一样）作为探测对方是否存活的手段（注意在IKE SA的语境下，“空”消息由IKE头部加上加密载荷组成-加密载荷中没有任何载荷）。如果最近从对方收到了加密保护的消息（新鲜的，而不是重传的），那么那些非加密保护的通知消息可以被忽略。IKE实现必须要基于非加密保护的消息的速率做出限制并采取行动。

重试的次数和超时时间的长度在本文当中未作指定，因为它们并不影响互操作性。建议在放弃SA之前，几分钟内至少重传十几次消息，但不同的环境可能需要不同的规则。作为网络好公民，重传的时间间隔必须呈指数级增长，以避免泛滥网络并使现有拥塞情况恶化。如果在与某IKE SA关联的所有SA上仅有传出流量，则必须确认另一个端点的存活以避免黑洞。如果最近在某IKE SA或其任何子SA上未收到加密保护的消息，则系统需要执行存活检查以防止向“死”节点发送消息。（这通常被称为“死节点检测”或“DPD”，应该它实际上是用来探测“活”节点，而非死的。）在IKE SA或其任何子SA上接收到新的加密保护消息能够确认其活跃性。注意这会对IKE节点的故障模式提出要求。如果某些故障阻止它在所有关联的SA上接收数据，则IKE实现需要停止通过这些SA发送数据。如果创建的子SA之间可以独立失败而无需通过IKE SA发送删除消息，那么系统必须使用单独的IKE SA协商这样的子SA???。

对于IKE SA的发起者存在DoS攻击，如果发起者采取适当的谨慎措施，则可以避免这种攻击。由于SA协商的前两个消息未受加密保护，因此攻击者可以在真正的响应者之前响应发起者的消息并破快连接建立。为了防止这种情况，发起者可能愿意接受对其第一条消息的多个响应，将每个响应视为可能合法，对其作出响应，然后在收到对其请求进行响应的任何一个有效加密保护的消息时丢弃所有其他无效的半开连接。一旦收到有效的加密保护的响应，它应当忽略所有后续响应，无论它们是否在加密保护有效的。

IKE节点可以随时删除不活动的子SA以恢复用于保持其状态的资源。如果IKE节点决定删除子SA，它必须向另一端发送删除载荷，通知它的删除。它可能以相同的机制老化IKE SA。关闭IKE SA会隐式关闭所有关联的子SA。在这种情况下，IKE端点应该发送一个Delete子载荷，表面它已关闭该IKE SA，除非另一个节点已经不再响应了。

### 2.5. 版本号和前向兼容性

本文档描述了IKE的2.0版本，意味着主要版本号为2，次要版本号为0。本文档是[IKEV2]的替代品。某些实现可能希望支持1.0版和2.0版，以及将来的其他版本。

仅当数据包格式或所需操作发生显着变化以致旧版本节点如果只是忽略了它不理解的字段并采取了指定的操作依然无法与较新版本节点互操作时，主要版本号才应该增加。在较旧的规范中。次要版本号表示新功能，并且该功能必须被具有较小次版本号的节点忽略，而被具有较大次要版本号的节点识别为信息用途。例如，它可能表示支持处理新定义的Notify消息类型。具有较大次要版本号的节点很容易知道对方将无法理解该消息，因此不会发送它。

如果端点收到具有较高主版本号的消息，它必须丢弃该消息，并且应该发送包含其支持的最高（最接近）版本号的INVALID_MAJOR_VERSION类型的明文Notify消息。如果端点支持主要版本n和主要版本m，它必须支持n和m之间的所有版本。如果它收到一个它支持的主要版本的消息，它必须以该版本号响应。为了防止两个节点被欺骗以至于最终协商主要版本号低于它们都能支持的最大版本号，IKE有一个标志为用于表明该节点能够支持更高的主要版本号。

因此，IKE标头中的主要版本号仅表示该消息的版本号，而不是发送器支持的最高版本号。如果发起者能够支持版本号n，n+1和n+2，响应者能够支持版本号n和n+1，那么他们将协商为版本号n+1，其中发起者将设置标志表明它能说更高的版本。如果他们错误地（可能是通过活跃的攻击者发送错误消息）协商到版本号n，那么两者都会注意到另一方可以支持更高版本号，那么他们必须断开现有连接并使用版本号n+1重新连接。

请注意，IKEv1并不遵循这些规则，因为在v1中没有办法表面通信节点能够支持更高的版本号。因此，活跃的攻击者可以将两个支持v2的节点欺骗以致他们协商为为v1。当支持v2的节点协商到v1时，它应该在其日志中注明该事实。

此外，为了向前兼容，运行版本2.0的实现必须将标记为RESERVED的所有字段置零，并且运行版本2.0的实现必须忽略它们的内容（“对发送消息保守，对接受消息保持自由”[IP]）。通过这种方式，协议的未来版本可以以保证被不理解它们的实现忽略这些字段。类似地，未定义的载荷类型保留供将来使用; 未定义某种类型载荷的版本的实现在遇到这些载荷试，必须忽略它们的内容。

IKEv2为每个载荷头添加了一个“critical”标志位，以进一步提高前向兼容的灵活性。如果设置了critical标志位，且接收方无法识别该载荷类型，接收方必须拒绝该消息，并且对包含该载荷的IKE请求发出包括UNSUPPORTED_CRITICAL_PAYLOAD通知载荷的回复消息，表明其接收到了不支持的critical载荷。在Notify载荷中，通知数据包含一个八位字节的载荷类型。如果接收到未设置critical标志且不支持的载荷类型，则必须忽略该载荷。在IKE响应消息的载荷不得设置critical标志位。请注意，critical标志仅适用于载荷类型，而不适用于载荷内容。如果识别出载荷类型，但载荷包含非有效内容（例如SA载荷内的未知变换，或Notify载荷内的未知通知消息类型），则忽略critical标志位。

虽然将来可能会添加新的有效载荷类型，并且可能与本规范中定义的字段交错，但实现应该按照第1节和第2节中图中所示的顺序发送本规范中定义的有效载荷；实现绝不能拒绝以其他顺序发送的带有这些有效负载的消息。

### 2.6. IKE SA SPIs和Cookies

IKE头部中开始的两个8字节字段称为“IKE SPI”，用作IKE数据包开始交换时的连接标识符。每个端点生成两个SPI中的一个，并且必须选择它们成为某IKE SA的唯一标识符。SPI值为零是特殊情况：它表示发送方尚不知道对方的SPI值。

接收到的IKE报文与IKE SA的映射关系仅通过SPI完成，为非（比如说）数据包的源IP。

与ESP和AH不同，只有接收方的SPI出现在消息的头部，在IKE中，发送者的SPI也在每条消息中发送。 由于发起IKE SA交换的原始发送方选择的SPI最先发送，维持多个IKE SA的节点想要使用它分配的SPI查找相应的IKE SA，则必须查看头中的Initiator标志以确定是被分配了第一个还是第二个8字节。

在IKE交换的第一条消息中，发起方并不知道响应者的SPI值，因此将该字段设置为0。 当IKE_SA_INIT交换由于INVALID_KE_PAYLOAD，NO_PROPOSAL_CHOSEN或COOKIE（参见第2.6节）而导致创建IKE SA失败时，回复消息中响应者的SPI依然置为0。但是，如果响应者发送非0的响应者SPI，则发起发不应仅为此而拒绝回复消息。

状态和CPU耗尽是对IKE的两种预期攻击类型，目标是使用大量伪造的IP地址发起会话请求。如果响应方在直到它知道发起方可以在它声称发送它们的地址处接收数据包之前，使用最小CPU资源并且不保存SA状态，那么这些攻击可能会变得不那么有效。

当响应者检测到大量半开的IKE SA时，它应该使用包含COOKIE通知的消息回复IKE_SA_INIT请求。 与此通知关联的数据必须在1到64个八位字节之间（包括），其生成将在本节后面介绍。 如果IKE_SA_INIT响应包含了COOKIE通知，则发起方必须重试IKE_SA_INIT请求，并包括包含接收数据的COOKIE通知作为第一个载荷，所有其他有效载荷不变。那么初始交换将会变成：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR(A,0), SAi1, KEi, Ni  -->
                                            <--  HDR(A,0), N(COOKIE)
    HDR(A,0), N(COOKIE), SAi1,
        KEi, Ni  -->
                                           <--  HDR(A,B), SAr1, KEr,
                                                    Nr, [CERTREQ]
    HDR(A,B), SK {IDi, [CERT,]
        [CERTREQ,] [IDr,] AUTH,
        SAi2, TSi, TSr}  -->
                                     <--  HDR(A,B), SK {IDr, [CERT,]
                                              AUTH, SAr2, TSi, TSr}

除了传递cookie之外，前两个消息不会影响任何协商状态。特别是，前四个消息中的消息ID都将为0，而最后两个消息中的消息ID将为1。 'A'是由发起发分配的SPI，而'B'是由响应方分配的SPI。

IKE实现可以启用响应方cookie，以便在第二个IKE_SA_INIT消息到达前不保存用于识别其有效cookie的任何状态信息。用于生成cookie的确切算法和语法不会影响互操作性，因此未在此处指定。以下是节点点如何使用cookie实现有限的DoS防护的示例。

执行此操作的一种好的方法是将响应方cookie设置为：

    Cookie = <VersionIDofSecret> | Hash(Ni | IPi | SPIi | <secret>)

其中<secret>是一个随机生成的秘密, 只有响应方知道并定期更改, “|”表示串联。每当重新生成<secret>时，都应更改<VersionIDofSecret>。当IKE_SA_INIT第二次到达时，重新计算cookie，并与接收消息中的cookie进行比较。如果匹配，则响应方知道该cookie是自上次更改为<secret>以来已生成的，并且该IPi与其第一次看到的源地址相同。将SPIi合并到计算中可确保如有多个并行IKE SA，它们将获得不同的cookie置（假设发送方选择了唯一的SPIi）。在散列中合并Ni可确保仅看到消息2的攻击者无法成功伪造消息3。此外，在散列中合并SPIi可防止攻击者从另一端获取一个cookie，然后使用不同的SPI发起许多IKE_SA_INIT交换（可能还有不通的端口号），导致响应方认为某个NAT设备后面有很多机器都在尝试连接。

如果在IKE SA初始化过程中<secret>的值发生了变化，则返回的第二个IKE_SA_INIT携带的cookie种与当前的<VersionIDofSecret>不同。 在这种情况下，响应者可以通过发送另一个带有新cookie的响应来拒绝该消息，或者它可以将<secret>的旧值保持一段时间并接受从任一个<secret>计算的cookie。 在<secret>更改后，响应者不应无限期地接受cookie，因为这会破坏部分DoS保护。 响应者应经常更改<secret>的值，尤其是在受到攻击时。

当一方收到包含其内容与预期值不匹配的cookie的IKE_SA_INIT请求时，它必须忽略该cookie，就好像没有包含cookie一样来处理该消息; 通常这意味着发送包含新cookie的响应。 发起者应该在放弃之前限制它尝试的cookie交换次数，可能使用指数后退。 攻击者可以伪造多个cookie以响应发起者的IKE_SA_INIT消息，每个伪造的cookie回复消息将导致两个数据包被发送：一个数据包从发起方到响应方（将拒绝这些cookie），一个来自响应者包含正确cookie的回复消息。

关于术语的说明：“cookies”一词起源于Photuris中的Karn和Simpson [PHOTURIS]，这是早期的IPsec密钥管理提案，并且一直存在。 互联网安全关联和密钥管理协议（ISAKMP）[ISAKMP]固定消息头部包含了两个8字节字段被称为“cookie”，IKEv1和IKEv2都使用该语法，尽管在IKEv2中它们被称为“IKE SPI”并且Notify载荷中有一个新的单独字段来保存cookie。

#### 2.6.1. COOKIE和INVALID_KE_PAYLOAD的交互

有两个常见原因导致发起方会重试IKE_SA_INIT交换：响应方回复cookie载荷或者想请求与KEi载荷中包含的DH组不同的DH组。如果发起方从响应方收到cookie载荷，则发起者需要决定是否仅在下一个IKE_SA_INIT重试请求中包含cookie，或者在所有后续重试都包含cookie。

如果发起方仅在下一次重试中包含cookie，则在某些情况下可能需要一次额外的交换。如果发起方在所有的重试中都包含cookie，但响应方不支持此操作，那么也需要额外的交换。例如，如果响应方在cookie计算中包含KEi有效载荷，它将通过发送新cookie来拒绝该请求。???

如果两个节点都支持在所有重试中包含cookie，则可以实现更短的交换过程：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR(A,0), SAi1, KEi, Ni -->
                                             <-- HDR(A,0), N(COOKIE)
    HDR(A,0), N(COOKIE), SAi1, KEi, Ni  -->
                                 <-- HDR(A,0), N(INVALID_KE_PAYLOAD)
    HDR(A,0), N(COOKIE), SAi1, KEi', Ni -->
                                         <-- HDR(A,B), SAr1, KEr, Nr

实现应该支持这种较短的交换，但如果其他实现不支持这种较短的交换，也绝不能产生失败的交换。

### 2.7. 加密算法协商

被称为“SA”的载荷类型用来表示针对SA的一组IPsec协议（IKE，ESP或AH）选择以及与每个协议相关联的加密算法的提议。

SA载荷由一个或多个提议组成。每个提议都包含一个协议。 每个协议都包含一个或多个变换 - 每个变换都指定一种加密算法。每个变换包含零个或多个属性（仅当变换ID未能完全表明加密算法时才需要属性）。

因为变换可接受多个值，变换本身的数量也不少，当支持的加密套件数量很大时，这种分层结构可以有效地编码加密套件的提议。响应者必须选择单个套件，该套件是接收到的SA提议的任何一个子集，具体选择遵循以下规则。

每个提议都包含一个协议。 如果提议被接受了，SA响应消息必须包含相同的协议。响应方必须接受整组提议或拒绝所有提议并返回错误通知。使用NO_PROPOSAL_CHOSEN类型的通知以返回错误。

每个IPsec协议提议都包含一个或多个变换。每个变换都包含一个变换类型。 接受的加密套件必须包含发起方提议中包含的每种变换类型的一个变换。 例如：如果ESP提议包括转换ENCR_3DES，ENCR_AES_128，ENCR_AES_256，AUTH_HMAC_MD5和AUTH_HMAC_SHA，则接受的套件必须包含一个ENCR_变换和一个AUTH_变换。 因此，一共有六种组合是可以接受的。

如果发起方提供了具有完整性保护的一般加密算法组合以及混合模式加密算法，则接收方也需要回复这两种类型的提议。其中一个提议包括完整性算法的普通加密算法组合，另一个提议包括没有完整性算法的混合模式加密算法组合（因为混合模式加密算法组合不允许具有除“None”之外的完整性算法）。

### 2.8. Rekeying

IKE，ESP和AH的SA使用的密钥应仅用在有限时间和有限数据。这样就限制了整个SA的生命周期。当SA的生命周期到期时，不得继续使用该SA。如果有需要，可以建立新的SA。 重新建立SA以取代过期SA的过程被称为“rekeying”。

最小的IPsec实现中，在不重启整个IKE SA的情况下重新生成SA的支持是可选的。实现可以拒绝IKE SA中的所有CREATE_CHILD_SA请求。如果SA已过期或即将过期并且使用此处描述的机制rekey的过程失败了，则实现必须关闭IKE SA和任何关联的子SA，然后重新协商新的IKE SA。实现可能希望支持SA的快速rekey，因为这样做可以提供更好的性能并且减少rekey期间丢包的数量。

要在现有IKE SA中rekey子SA，需要先创建一个新的子SA（参见下面的第2.17节），并在新的子SA建立后删除旧的。请注意，在reky时，新的子SA要使用与旧的SA完全相同的流量选择器和加密算法。

要rekey IKE SA，先使用现有IKE SA中的CREATE_CHILD_SA与节点建立新的IKE SA（请参阅下面的第2.18节）。如此创建的IKE SA继承了所有原始IKE SA的子SA，新的IKE SA将维护这些子SA所需的所有控制消息。创建新的IKE SA后，发起方将删除旧的IKE SA，删除IKE SA自身使用的删除载荷必须是通过该IKE SA发送的最后一个请求。

SA应该积极的rekey，即新的SA应该在旧的SA到期并失效之前建立。在新SA建立和旧SA失效之间应该预留足够的时间，以便可以将流量平滑地切换到新SA。

IKEv1和IKEv2之间的其中一个区别是，在于IKEv1中SA的生存期是经过协商的。而在IKEv2中，SA的每一方负责在SA上执行其生命周期策略，并在必要时rekey SA。如果两端具有不同的生命周期策略，则具有较短生命周期的将始终是发起rekey的那一方。如果SA长时间处于非活跃状态，并且端点在没有流量的情况下未无需SA，则端点可以选择关闭SA，而无需在其生存期到期时reky SA。如果自上次rekey SA以来没有过流量，它也可以选择关闭SA。

请注意，IKEv2有意设计为允许在通信端点之间建立具有相同流量选择器的并行SA。其中一个目的是支持SA之间的业务服务质量（QoS）差异（参见[DIFFSERVFIELD]，[DIFFSERVARCH]和[DIFFTUNNEL]的4.1节）。因此，与IKEv1不同，端点和流量选择器的组合可能无法唯一地标识这些端点之间的SA，因此不应像使用类似IKEv1的启发式SA删除机制，通过发现重复流量选择器而删除SA。

时间窗口在这里很重要——特别是在丢包的情况下——通信两端的SA状态可能不一致。CREATE_CHILD_SA的响应方必须在发送回复消息之前准备好接受新SA上的消息，使得对发起方没有歧义???。发起方一旦处理CREATE_CHILD_SA的回复消息，就可以使用新的SA发送数据。但是，在收到并处理对其CREATE_CHILD_SA请求的响应之前，发起方禁止在新的SA上接收数据。那么，响应方该如何判断何时可以在新的SA上发送数据呢？

从技术正确性和互操作性的角度来看，响应方可以在将其发出来CREATE_CHILD_SA请求的回复消息之后立即开始使用新的SA发送数据。但是，在某些情况下，这可能会导致数据包被不必要地丢弃，因此实现可能会推迟这种发送。

如果（1）响应方已经从SA的另一端上接收到加密有效消息，或者（2）新SA rekey现有SA并且响应方收到了关闭旧SA的IKE 请求报文，则响应方可以确保发起方已经准备好了在新SA上接收数据。在rekey SA时，响应方应该继续在旧SA上发送流量，直到上述其中一个事件发生。在建立新的SA时，响应方可以推迟在新SA上发送消息，直到它（在新SA上）收到一个消息或发生超时。如果发起方在尚未收到对其CREATE_CHILD_SA请求的响应时在新SA上接收到了数据，则它将应将消息解释为可能发生了丢包并重新发送CREATE_CHILD_SA请求。如果没有排队等待发送的数据，发起方可以在新创建的ESP SA上发送虚拟ESP数据，以便向响应方确认已准备好接收消息。

#### 2.8.1. 子SA同时rekey

如果IKE两端具有相同的SA生存周期期策略，则有可能出现同时启动rekey的情况（这将导致冗余SA）。 为了减少发生这种情况的可能性，实际rekey的间隔时间应该被抖动处理（在注意到需要rekey时随机延迟一段时间）。

这种形式的rekey可能会暂时导致同一对节点之间同时出现多个类似的SA。当同时有两个有资格的SA接收数据包时，该节点必须接收通过任何一个SA传入的数据。如果在这种冲突情况下创建了冗余的SA，则在IKE交换中使用的四个nonce中最低的那一个SA应该由创建它的节点关闭。“最低”表示八位字节之间比较（而不是将nonce作为整体数值作为比较）。换句话说，首先比较第一个八位字节;如果它们相等，则移动到下一个八位字节，依此类推。如果你到达一个nonce的尾部，那该nonce就是值较小的那一个。最种幸存的SA的发起方应该在新的SA建立后删除旧的SA。

以下是同时rekey情况对实现影响的具体说明。假设主机A和B现有子SA的SPI为（SPIa1，SPIb1），并且两方同时发起rekey：

    主机A                                                      主机B
    ----------------------------------------------------------------
    send req1: N(REKEY_SA,SPIa1),
        SA(..,SPIa2,..),Ni1,..  -->
                                  <--  send req2: N(REKEY_SA,SPIb1),
                                                 SA(..,SPIb2,..),Ni2
    recv req2 <--

此时，A知道发送了同时rekey。但是，它还不知道哪个交换消息使用的nonce时最低的，因此尽管它注意到了这种情况，仍然正常作出回复。

    主机A                                                      主机B
    ----------------------------------------------------------------
    send resp2: SA(..,SPIa3,..),
         Nr1,..  -->
                                                      -->  recv req1

现在，B也知道了发生了同时rekey。它也正常做出回复。

    主机A                                                      主机B
    ----------------------------------------------------------------
                                   <--  send resp1: SA(..,SPIb3,..),
                                            Nr2,..
    recv resp1 <--
                                                     -->  recv resp2

此时，A和B之间有三个子SA对（1个旧的和2个新的）。A和B现在可以比较nonce的大小。假设消息resp2中的nonce Nr1时最小的;在这种情况下，B（req2的发送方）会删除冗余的新SA，A（发起SA rekey的节点）会删除旧的SA。

随后，rekey结束。

但是，如果网络中出现了丢包，则会发生第二种可能的事件序列，从而导致重新传输。Rekey像平常一样开始，但A的第一个数据包（req1）丢失了。

    主机A                                                      主机B
    ----------------------------------------------------------------
    send req1: N(REKEY_SA,SPIa1),
        SA(..,SPIa2,..),
        Ni1,..  -->  (lost)
                                  <--  send req2: N(REKEY_SA,SPIb1),
                                           SA(..,SPIb2,..),Ni2
    recv req2 <--
    send resp2: SA(..,SPIa3,..),
        Nr1,.. -->
                                                     -->  recv resp2
                                            <--  send req3: D(SPIb1)
    recv req3 <--
    send resp3: D(SPIa1) -->
                                                     -->  recv resp3

从B的角度来看，rekey现在已经完成，并且由于它还没有收到A的req1，它甚至不知道发生了同时rekey。但是，A将继续重传该消息，并最终将到达B。

    主机A                                                      主机B
    ----------------------------------------------------------------
    resend req1 -->
                                                      -->  recv req1

对于B来说，A是在尝试对一个已经不存在的SA进行rekey；所以B将会议一个一般错误通知，例如CHILD_SA_NOT_FOUND。

    主机A                                                      主机B
    ----------------------------------------------------------------
                              <--  send resp1: N(CHILD_SA_NOT_FOUND)
    recv resp1 <--

当A收到此错误通知时，它就知道发生了同时rekey，它可以忽略该错误通知。

#### 2.8.2. IKE SA同时rekey

最复杂的情况可能是两个节点同时尝试rekey IKE SA。基本上，第2.8节中的文字也适用于这种情况; 但是，如何确保Child SAs由正确的IKE_SA继承尤为重要。

通信两端发现同时rekey的机制与子SA相同。在CREATE_CHILD_SA交换之后，A和B之间存在三个IKE SA：旧的IKE SA和两个新的IKE SA。包含最低nonce的新IKE SA应该由创建它的节点删除，而另一个新IKE SA必须继承所有子SA。

除了正常的同时rekey情况之外，还有一种特殊情况，即一个节点在注意到另一节点进行rekey之前就完成己方发起的rekey。如果只有一个节点检测到同时rekey，则不会创建冗余SA。 在这种情况下，没有注意到同时rekey的节点在接收到已完成rekey的IKE SA的rekey请求时，它应该返回TEMPORARY_FAILURE错误通知，因为该请求是当前正在尝试关闭的IKE SA的rekey请求（无论是否它已发送了SA的删除通知）。如果检测到同时rekey的节点在旧的IKE SA上收到了另一个节点的删除请求，则它知道另一个节点没有检测到同时rekey，那个该节点可以清除它自己的rekey尝试。

    主机A                                                      主机B
    ----------------------------------------------------------------
    send req1:
         SA(..,SPIa1,..),Ni1,.. -->
                              <-- send req2: SA(..,SPIb1,..),Ni2,..
                              --> recv req1
                              <-- send resp1: SA(..,SPIb2,..),Nr2,..
    recv resp1 <--
    send req3: D() -->
                              --> recv req3

此时，主机B看到关闭IKE_SA的请求。除了照常回复之外别无其他选择。但是，此时主机B应该停止重传req2，因为一旦主机A收到resp3，它将删除与旧IKE_SA相关联的所有状态，从而将无法回复重传的req2。

    主机A                                                      主机B
    ----------------------------------------------------------------
                              <-- send resp3: ()

RFC 4306中未包含TEMPORARY_FAILURE通知，也未讨论对TEMPORARY_FAILURE通知的支持。因此，遵循RFC 4306而非本文的较旧的实现可能会收到这些通知。在这种情况下，他们会将其视为未知错误通知，并将停止交换。而因为另一节点已经完成了rekey，所以这样做没有任何不良影响。

#### 2.8.3. IKE SA rekey和重认证

IKE SA rekey和重认证在IKEv2中是不同概念。IKE SA rekey会为IKE SA建立新密钥并重置消息ID计数器，但它不会再次对各方进行身份验证（不会涉及AUTH或EAP载荷）。

虽然在某些环境中IKE SA rkey可能很重要，但重认证（保证通信双方仍然能被证明可以访问其长期凭证）通常更为重要。

IKEv2对重认证没有任何特殊支持。重认证就是通过从头开始创建新的IKE SA（使用IKE_SA_INIT/IKE_AUTH交换，没有任何REKEY_SA Notify载荷），在新的IKE SA中创建新的子SA（没有REKEY_SA Notify载荷），最后删除旧的IKE SA（同时删除旧的子SA）而完成。

这意味着重认证也会为IKE SA和子SA建立了新密钥。因此，reky比重认证更频繁地执行，而“认证生存期”比“密钥生存期”更短的设置便没有任何意义。

虽然任何一方（原始IKE SA中的发起者或响应者）都可以创建新的IKE SA，但是使用EAP和/或配置载荷的情况下，必须由与原始IKE SA相同的发起方发起重认证。在这种情况下，目前IKEv2不允许原先的响应方发起重认证;但是，有一些扩展可以添加此功能，例如[REAUTH]。

### 2.9. 流量选择器协商

当符合RFC4301的IPsec子系统接收到与其安全策略数据库（SPD）中存在的“保护”选择器匹配的IP数据包时，子系统会使用IPsec保护该数据包。 如果相应的SA不存在，创建它便是IKE的任务。维护系统的SPD超出了IKE的范围，尽管某些实现可能会将SPD的更新与IKE的运行状态相关连（有关示例方案，请参见第1.1.3节）。

流量选择器（TS）载荷允许节点将来自其SPD的一些信息传递给对等体。这些信息必须从SPD传递给IKE（例如，使用SADB_ACQUIRE消息的PF_KEY API [PFKEY]）。TS载荷指定将通过新建SA转发数据包分组的选择标准。在某些情况下，这可以作为一致性检查的手段，以确保SPD是一致的。在其他情况下，它也能指导SPD的动态更新。

TS载荷会出现在创建子SA的每一个交换消息中。每个TS载荷包含一个或多个流量选择器。每个流量选择器由地址范围（IPv4或IPv6），端口范围和IP协议ID组成。

两个TS有效载荷中的第一个被称为TSi（流量选择器 - 发起方）。第二个被称为TSr（流量选择器 - 响应方）。TSi表示从子SA对的发起方发送流量的源地址（或接收流量的目的地址）。TSr表示子SA对的响应方接收流量的目的地址（或发送流量的源地址）。例如，如果发起方在请求创建子SA时，希望将所有流量从发起方的子网198.51.100.* 路由到响应方的子网192.0.2.* ，则发起方将在每一个TS载荷中设置一个单独的流量选择器。TSi将指定地址范围（198.51.100.0 - 198.51.100.255），TSr将指定地址范围（192.0.2.0 - 192.0.2.255）。假设该提议对响应方是可接受的，它将发回相同的TS载荷。

IKEv2允许响应方选择发起方提议的流量的子集。当更新两个节点中只有一端收到配置更新信息时，可能会发生这种情况。由于两个节点可以由不同的人配置，即使在没有错误的情况下，这种不一致的情况可能持续较长的一段时间。它还允许有意为之的不同配置，例如，当一端配置为为所有地址打隧道而依赖于另一端负责更新地址列表时。

当响应方选择发起方提议流量的子集时，它将流量选择器缩小到发起方提议的某个子集（假设该集合不为空）。如果提议的流量选择器类型未知，则响应者会忽略该流量选择器，这样在子集种就不返回未知类型。

为了使响应方能够在这种情况下选择适当的范围，如果发起方尝试建立的SA时有数据驱动的，则发起方应该在TSi和TSr的中使用非常具体的流量选择器作为第一个流量选择器，其仅包含驱动SA建立的数据包的源和目的地址。举个例子，发起者将在TSi中包括两个流量选择器：第一个包含地址范围（198.51.100.43-198.51.100.43）以及数据包的源端口和IP协议；第二个包含（198.51.100.0-198.51.100.255）包含所有端口和IP协议。同样，TSr中也会包括两个响应的流量选择器。如果发起方创建子SA的行为不是由数据包驱动的，而是，例如，在IKE启动时发生，则发起方可能没有特定地址优先于任何其他地址。在这种情况下，TSi和TSr中的第一个值可以是范围而不是特定值。

响应方根据以下规则缩小流量选择器：

+ 如果响应方的策略不允许它接受提议流量选择器的任何部分，它将以TS_UNACCEPTABLE通知消息进行响应。

+ 如果响应方的策略接受TSi和TSr覆盖的整个流量集，则不需要缩小，响应方返回相同的TSi和TSr值。

+ 如果响应方的策略允许它接受第一个流量选择器中的TSi和TSr，则响应方必须将流量选择器缩小与该选择器相同的子集。在上面的这个例子中，响应方可能会回复IP范围（198.51.100.43-198.51.100.43）以及所有端口和IP协议的TSi。

+ 如果响应方的策略不允许它接受TSi和TSr的第一个选择器，则响应者缩小到可接受的TSi和TSr子集。

当缩小完成时，可能有几个子集是可以接受的，而它们的并集却不是。在这种情况下，响应方任意选择其中一个进行响应，并且可以在响应中包括ADDITIONAL_TS_POSSIBLE通知。ADDITIONAL_TS_POSSIBLE通知表明响应方缩小了提议的流量选择器，但其他流量选择器也是可接受的，尽管只在新建单独的SA中。此通知类型无需携带数据。只有当发起方和响应方的配置不同时，才会出现这种情况。如果发起方和响应方就隧道的保护范围达成一致，则发起方将永远不会请求比响应方接受的更宽的隧道。

响应方的策略可能包含多个较小的范围，它们全部被包含在发起方提议的流量选择器中，根据响应方的策略，它期望每个小的范围通过不同的SA发送。继续上面的示例，响应方的策略可能配置为接受将这些地址与发起方进行隧道传送，但要求每个地址对使用不同的子SA。如果发起方请求不是数据驱动的，例如在IKE启动时，则不会有非常具体的第一个流量选择器帮助响应方选择正确的流量范围。那么响应方就无法确定应在此隧道中包含哪一对地址，它就必须使用SINGLE_PAIR_REQUIRED通知消息进行猜测或拒绝该请求。

SINGLE_PAIR_REQUIRED错误表示CREATE_CHILD_SA请求是不可接受的，因为它的发送方只愿意接受提议流量选择器中的一对地址。消息发送方期望接收方发起仅针对其指定的特定流量发起SA交换请求。

很少有实现具有针对每个地址都需要单独SA的策略。因此，如果响应者方只接受发起者提出的TSi和TSr的某一部分，则响应方应该将选择器缩小到可接受的子集，而不是使用SINGLE_PAIR_REQUIRED。

#### 2.9.1. 违反本地配置策略的流量选择器

在创建新SA时，发起方要避免提议违反其自身策略的流量选择器。如果不这样的话，有可能会导致丢弃有效流量。 如果遵循了[IPSECARCH]中的去相关策略，则不会发生此类违反策略的情况。

通过一个例子来说明。假设主机A有一个策略，其效果是到198.51.100.66的流量使用AES加密发送给主机B，而到198.51.100.0/24中所有其他主机的流量也发送给B，但必须使用3DES加密。假设主机B接受AES和3DES的任何组合。

如果主机A现在提议使用3DES并且包含TSr（198.51.100.0-198.51.100.255）的SA，并且主机B接受了。主机B通过此SA可以发送源为198.51.100.66的流量到A，但是这些数据包将被A丢弃，因为它需要这些流量使用AES加密。即使主机A为使用AES并发往198.51.100.66的流量创建新的SA，主机B也可能自由地继续使用第一个SA。这种情况下，在提议SA时，发送方A应该遵循自己的政策，生成包含（（198.51.100.0- 198.51.100.65），（198.51.100.67-198.51.100.255））的TSr。

通常，如果（1）发起者“为流量X（TSi / TSr）提议并建立SA”，并且（2）对于X的某个子集X'，则发起方不通过该SA接收流量X'，（3）发起方愿意通过其他某些SA'（！= SA）接受流量X'，那么有效流量就可能被丢弃，因为SA的响应方可以选择使用SA或者SA'来发送流量X'。

### 2.10. Nonces

IKE_SA_INIT消息每个都包含一个随机数。这些随机数用作加密函数的输入。CREATE_CHILD_SA请求和CREATE_CHILD_SA响应也包含nonce。这些随机数用于为生成Child SA密钥的算法增加新鲜度，并确保从Diffie-Hellman密钥创建强伪随机数。IKEv2中使用的随机数必须是随机选择的，必须至少为128位，并且必须至少是协商的伪随机函数（PRF）密钥长度的一半。但是，发起方是在知道协商结果之前生成nonce的。因此，nonce必须足够长，以便适用于所有PRF。如果同一个随机数源同时用于密钥和随机数，则必须注意确保后者的不会泄露前者。

### 2.11. 地址和端口灵活性

IKE在UDP端口500和4500上运行，并隐式地为相同IP地址设置ESP和AH关联。但是，外层头部中的IP地址和端口本身不受加密保护，IKE甚至可以工作在网络地址转换（NAT）的环境下。即使源端口不是500或4500，实现也必须接受传入的请求，并且必须发送响应到接收请求的源地址和源端口。它必须将接收到请求的地址和端口作为响应中的源地址和源端口。IKE的功能在IPv4和IPv6中没有区别。

### 2.12. Diffie-Hellman指数重用

IKE使用短暂的Diffie-Hellman交换生成密钥材料，以获得“完美前向保密”（PFS）的特性。这意味着一旦连接关闭并且删除了的密钥，那么即使是从连接中记录了所有传输的数据并且获取了两个端点所有之前的长期密钥，攻击者也无法还原用于保护连接的密钥，除非对会话密钥的空间进行穷举攻击。

实现PFS就要求当连接关闭时，每个端点不仅要删除连接使用的密钥，还要删除可用于重新计算这些密钥的任何信息。

因为计算Diffie-Hellman指数是非常消耗资源的，所以端点可能发现将这些指数重用于多个连接可以节省资源。几种合理的策略可以实现该效果。端点可以定期选择新的指数，但如果某些连接的持续时间小于指数的生命周期，则可能不能实现PFS。或者，它可以跟踪每个连接使用的指数，并仅在某些相应的连接关闭时删除与指数相关的信息。这将在实现指数重用的同时，不会以维持更多状态为代价而失去PFS。

是否以及何时重用Diffie-Hellman指数是私有决策，因为它们不会影响互操作性。重用指数的实现可以选择记住其他端点在过去的交换中使用的指数，当该指数被复用是可以节省开销。有关此实践的安全性分析以及其他安全注意事项，请参阅[REUSE]。

### 2.13. 密钥生成材料

在IKE SA的情境中，一共协商了四种加密算法：加密算法，完整性保护算法，Diffie-Hellman组和伪随机生成函数（PRF）。PRF用于构建IKE SA和子SA所有相关加密算法的密钥材料。

我们假设每个加密算法和完整性保护算法使用固定长度的密钥，并且该固定长度的任何随机数值都可以用作的密钥。对于接受可变长度密钥的算法，必须将一定长度的密钥长度做为协商的提议变换的一部分（有关密钥长度变换属性的定义，请参见第3.3.5节）。对于并非所有值都是有效密钥的算法（例如DES或密钥奇偶校验的3DES），从任意值导出密钥的算法必须在加密变换中指定。

对于基于散列消息认证码（HMAC）的完整性保护功能，密钥的长度是底层散列函数的输出长度。

假设PRF接受任何长度的密钥，但同时有一个首选的密钥长度。首选密钥长度必须用作SK_d，SK_pi和SK_pr的长度（参见第2.14节）。对于基于HMAC构造的PRF，优选密钥长度等于底层散列函数的输出长度。其他类型的PRF必须指定其首选密钥长度。

密钥材料将始终作为协商的PRF算法的输出导出。由于所需的密钥材料的数量可能大于PRF的输出的长度，PRF应当反复使用。术语“prf+”意为基于名为“prf”的伪随机函数的输入，输出伪随机数的函数。

下文，|表示并列关系。prf+可以定义为：

    prf+ (K,S) = T1 | T2 | T3 | T4 | ...

其中：

    T1 = prf (K, S | 0x01)
    T2 = prf (K, T1 | S | 0x02)
    T3 = prf (K, T2 | S | 0x03)
    T4 = prf (K, T3 | S | 0x04)
    ...

计算一直持续到所有密钥所需材料都从prf+输出。密钥将自输出字符串中分别取出，无需考虑边界（例如，如果所需密钥是AES 256位和HMAC密钥160位，如果prf函数输出位160位，AES密钥将取自T1，和T2的开头部分，而HMAC密钥将取自T2的其余部分和T3的开头部分）。

每个prf函数末尾的连接常量是一个八位字节。prf +函数的输出不超过prf函数输出大小的255倍。

### 2.14. IKE SA的密钥材料生成

共享密钥计算如下。基于IKE_SA_INIT交换期间交换的随机数和通过交换生成的Diffie-Hellman共享密钥，可以计算出被称为SKEYSEED的常量。SKEYSEED用于计算其他七个秘密：SK_d用于导出使用此IKE SA建立的子SA的新密钥; SK_ai和SK_ar用作完整性保护算法的密钥，用于验证后续交换的消息; SK_ei和SK_er用于加密（当然是解密）所有后续交换; 以及SK_pi和SK_pr，它们用于生成AUTH载荷时。SK_d，SK_pi和SK_pr的长度必须是商定的PRF的首选密钥长度。

SKEYSEED及其衍生秘密计算如下：

    SKEYSEED = prf(Ni | Nr, g^ir)

    {SK_d | SK_ai | SK_ar | SK_ei | SK_er | SK_pi | SK_pr }
                    = prf+ (SKEYSEED, Ni | Nr | SPIi | SPIr )

(表示从prf+的生成位开始按顺序获取常数SK_d，SK_ai，SK_ar，SK_ei，SK_er，SK_pi和SK_pr)。g ^ir是通过Diffie-Hellman交换的生成的共享秘密。如果需要，g^ir表示为用零填充的大端序列的八位字节串，以使其满足模数的长度要求。Ni和Nr是nonce。出于后向兼容的原因，有两个PRF在此计算中被特别处理。 如果协商的PRF是AES-XCBC-PRF-128 [AESXCBCPRF128]或AES-CMAC-PRF-128 [AESCMACPRF128]，则仅使用Ni和Nr的前64位计算SKEYSEED，但它们的所有位都用于prf+函数的输入。

数据流的两个方向使用不同的密钥。用于保护来自原始发起方消息的密钥是SK_ai和SK_ei。用于保护另一方向消息的密钥是SK_ar和SK_er。

### 2.15. IKE SA的认证

当不使用可扩展认证时（参见第2.16节），通过对数据块进行签名（或使用共享密钥填充生成MAC，如本节后面所述）完成对对等体的认证。在这些计算中，IDi'和IDr'是对除IKE头部之外的整个报文生成摘要的ID载荷。对于响应方来说，要签名的数据以第二个消息（IKE_SA_INIT响应）的头部中的SPI的第一个八位字节开始，并以该消息中最后一个载荷的最后一个八位字节结束。除此之外（为了计算签名），还有发起者的nonce Ni（只是值，而不是包含它的载荷），以及值prf（SK_pr，IDr'）。注意，nonce Ni和值prf（SK_pr，IDr'）不会被发送。类似地，发起方给第一条消息（IKE_SA_INIT请求）签名，从头部第一个SPI的第一个八位字节开始，到最后一个载荷的最后一个八位字节结束。之后（为了计算签名）是响应方的随机数Nr，以及值prf（SK_pi，IDi'）。每一方都将另一方的随机数进行签名对于交换的安全性至关重要。

发起方的签名数据可以描述为：

    InitiatorSignedOctets = RealMessage1 | NonceRData | MACedIDForI
    GenIKEHDR = [ four octets 0 if using port 4500 ] | RealIKEHDR
    RealIKEHDR =  SPIi | SPIr |  . . . | Length
    RealMessage1 = RealIKEHDR | RestOfMessage1
    NonceRPayload = PayloadHeader | NonceRData
    InitiatorIDPayload = PayloadHeader | RestOfInitIDPayload
    RestOfInitIDPayload = IDType | RESERVED | InitIDData
    MACedIDForI = prf(SK_pi, RestOfInitIDPayload)

响应方的签名数据可以描述为：

    ResponderSignedOctets = RealMessage2 | NonceIData | MACedIDForR
    GenIKEHDR = [ four octets 0 if using port 4500 ] | RealIKEHDR
    RealIKEHDR =  SPIi | SPIr |  . . . | Length
    RealMessage2 = RealIKEHDR | RestOfMessage2
    NonceIPayload = PayloadHeader | NonceIData
    ResponderIDPayload = PayloadHeader | RestOfRespIDPayload
    RestOfRespIDPayload = IDType | RESERVED | RespIDData
    MACedIDForR = prf(SK_pr, RestOfRespIDPayload)

请注意，所有载荷都将用于签名，包括本文档中未定义的任何载荷类型。如果交换的第一条消息多次发送（例如启用了响应方cookie和/或不同的Diffie-Hellman组），则签名将使用消息的最新版本。

可选地，消息3和4可以包括证书或证书链，用以证明用于计算数字签名的密钥属于ID载荷中的指定的名称。签名或MAC将使用由签名者使用的密钥类型决定的算法来计算，并在Authentication载荷中的Auth Method字段指定。发起方和响应方可以使用不同的加密算法签名。加密算法的选择取决于双方的密钥类型。特别地，发起方可以使用共享密钥，而响应方使用公钥和证书。通常情况是（但不是必需的），如果使用共享密钥认证，则在两个方向上使用相同的密钥。

请注意，使用共享密钥是一种常见的但通常不安全的做法，因为共享密钥仅来自用户选择的密钥，而不包含其他随机源。这通常是不安全的，因为用户选择的密钥不太可能抵抗字典攻击，并且在这种认证方法不会阻止这些攻击。（基于密码的身份验证进行自举和建立IKE SA的应用程序应使用第2.16节中的身份验证方法，该方法旨在防止脱机字典攻击。）预共享密钥需要包含与正在协商的最强密钥一样多的不可预测性。在预共享密钥的情况下，AUTH值计算如下：

对于发起方：

    AUTH = prf( prf(Shared Secret, "Key Pad for IKEv2"),
                     <InitiatorSignedOctets>)

对于响应方：

    AUTH = prf( prf(Shared Secret, "Key Pad for IKEv2"),
                     <ResponderSignedOctets>)

“Key Pad for IKEv2”是17个ASCII字符，不包含空终止。共享密钥是可变长度的。添加填充字符串，以便如果共享密钥是从密码派生的，则IKE实现不需要以明文形式存储密码，而是可以存储值prf(Shared Secret, "Key Pad for IKEv2")，而这不能用作除IKEv2之外其他协议的密码。如前文所述，从密码导出共享秘密是不安全的。使用这种结构是因为预计人们无论如何都会这样做。提供共享密钥的管理接口必须接受至少64个八位字节的ASCII字符串，并且在将它们用作共享密钥之前不得添加空终止符。它还必须接受十六进制编码的共享密钥。如果指定了将编码转换为二进制字符串的算法，则管理接口也可以接受其他类型的编码。

有两种类型的EAP身份验证（在第2.16节中描述），每种类型在计算AUTH时使用不同的值。如果是生成密钥的EAP，则在计算中使用主会话密钥（MSK）为替换共享密钥。对于非生成密钥的EAP，分别用SK_pi和SK_pr替换两个AUTH计算中的共享密钥。???

### 2.16. 可扩展认证协议

除了使用公钥签名和共享密钥进行身份验证之外，IKE还支持使用RFC 3748 [EAP]中定义的方法进行身份验证。通常，这些方法是非对称的（为服务器对用户进行认证而设计），并且它们可能不是相互的。出于这个原因，这些协议通常用向响应方去验证发起方，并且必须与响应方对发起方的基于公钥签名的认证一起使用。这些方法通常与称为“传统认证”的机制相关联。

虽然本文档引用了[EAP]，意图在未更新此规范的情况下可以添加新方法，但此处记录了一些更简单的变体。[EAP]定义了需要可变数量消息的认证协议。可扩展认证在IKE中实现必须通过额外IKE_AUTH交换，以初始化IKE SA。

发起方通过从IKE_AUTH交换中第一个消息中省略AUTH载荷来表明希望使用EAP。（请注意，AUTH载荷是非EAP身份验证所必需的，因此在本文的其余部分中未标记为可选。）通过仅包含IDi载荷但不包含AUTH载荷，发起方已声明了身份但尚未证明它。如果响应者愿意使用EAP方法，它将在IKE_AUTH交换的响应中放置EAP载荷，并推迟发送SAr2，TSi和TSr，直到通过后续IKE_AUTH交换完成对发起方认证。在最简EAP方法的情况下，初始SA建立将如下所示：

    发起方                                                    响应方
    ----------------------------------------------------------------
    HDR, SAi1, KEi, Ni  -->
                                  <--  HDR, SAr1, KEr, Nr, [CERTREQ]
    HDR, SK {IDi, [CERTREQ,]
        [IDr,] SAi2,
        TSi, TSr}  -->
                                    <--  HDR, SK {IDr, [CERT,] AUTH,
                                            EAP }
    HDR, SK {EAP}  -->
                                        <--  HDR, SK {EAP (success)}
    HDR, SK {AUTH}  -->
                                <--  HDR, SK {AUTH, SAr2, TSi, TSr }

如2.2节所述，当使用EAP时，每对IKE SA初始设置消息的消息号都会增加; 第一对AUTH消息的ID为1，第二对为2，依此类推。

对于使用共享密钥作为协助身份验证的EAP方法，发起方和响应方必须使用该共享密钥作为材料，使用第2.15节中指定的共享密钥语法在消息7和8中生成AUTH载荷。来自EAP的共享密钥是规范名为MSK的字段。在IKE交换期间生成的此共享密钥不得用于任何其他目的。

不生成共享密钥的EAP方法不应该使用，因为如果这些EAP方法在不使用服务器认证隧道的其他协议中使用时会受到许多中间人攻击[EAPMITM]的影响。有关详细信息，请参阅安全注意事项部分。如果使用不生成共享密钥的EAP方法，则必须分别使用SK_pi和SK_pr生成消息7和8中的AUTH载荷。

在响应方发送通知消息和/或重试认证提示的情况下，使用EAP的IKE SA的发起方需要能够将初始协议交换扩展到至少十个IKE_AUTH交换。一旦由所选EAP身份验证方法定义的协议交换成功终止，响应者必须发送包含Success消息的EAP载荷。 同样，如果身份验证方法失败，响应者必须发送包含失败消息的EAP载荷。响应方可以随时通过发送包含失败消息的EAP载荷来终止IKE交换。

在这种扩展交换之后，EAP AUTH载荷必须包含在有EAP成功载荷之后的两个消息中。

当发起方身份验证使用EAP时，IDi载荷的内容可能仅用于身份验证，授权和记帐（AAA）路由目的，并声明选择使用哪种EAP方法。此值可能与EAP方法验证的身份不同。策略匹配和访问控制使用实际经过验证的身份是非常重要的。通常，EAP服务器在独立于与IKEv2响应方的单独AAA服务器中实现。在这种情况下，如果认证身份身份信息与IDi有效载荷中的身份不同，则必须将认证身份从AAA服务器发送到IKEv2响应方。

### 2.17. 子SA密钥材料生成

单个的子SA由IKE_AUTH交换产生，额外的子SA可以可选的由CREATE_CHILD_SA交换产生。它们使用的密钥材料依据如下生成：

    KEYMAT = prf+(SK_d, Ni | Nr)

其中，当通过IKE_SA_INIT生成首个子SA时，Ni和Nr为IKE_SA_INIT中的Nounce；而当通过CREATE_CHILD_SA交换生成后续子SA时，Ni和Nr为当前交换中的新Nounce。

对于使用了可选DH组的CREATE_CHILD_SA交换，密钥材料为：

    KEYMAT = prf+(SK_d, g^ir (new) | Ni | Nr )

其中，g^ir (new)为当前CREATE_CHILD_SA交换的临时共享秘密（表示为高位优先的8位字符串，必要时高位填充0以便形成模数）。

单次CHILD_SA的协商可能会产生多个SA。ESP和AH SA以成对的形式生成（每个方向一个SA），因此单次CHILD_SA产生了两个SA。此外，子SA协商亦可包括某些未来的IPSec协议，作为ESP/AH的补充或替代（例如，ROHC_INTEG，参见[ROHCV2]）。无论怎样，每个子SA的密钥材料在由扩充的KEYMAT推导时，必须遵循以下规则：

+ 所有的应用于发起方到响应方流量SA的密钥生成要先于应用于反向流量的SA。

+ 当协商多种IPSec协议时，每个子SA密钥材料生成顺序要与协议头部在封包出现的顺序一致。

+ 若某中IPSec协议要求多个密钥材料，该协议需要在其规范中说明这些材料的获取顺序。对于ESP和AH，[IPSECARCH]定义了该顺序，即：加密材料（如需）必须位于第一位，完整性材料（如需）必须位于之后。

每种密码学算法在将从密钥材料中获取事先声明的固定bit位作为密钥材料，或者在SA载荷中协商（密钥材料长度参见2.13，密钥材料长度转换参数参见3.3.5）。

### 2.18. 使用CREATE_CHILD_SA交换更新IKE SA

CREATE_CHILD_SA交换可用于更新已有的IKE SA（参见1.3.2和2.8）。新的发起方和响应方SPI在SA载荷中的提议部分的SPI字段声明。而TS载荷在更新IKE SA将被省略。用于新IKE SA的SKEYSEED将使用现有IKE SA中的SK_d由以下算法计算：

    SKEYSEED = prf(SK_d (old), g^ir (new) | Ni | Nr)

其中，g^ir (new)为当前CREATE_CHILD_SA交换的临时共享秘密（表示为高位优先的8位字符串，必要时高位填充0以便形成模数），而Ni和Nr为从任意头部提取的nouce。

新旧IKE SA可能会使用不同的PRF。但由于更新SA的交换仍使用旧的SA进行，产生SKEYSEED的PRF将使用就SA的算法。

更新SA的主要原因是为了确保旧有密钥的泄露不会为新密钥的破解提供任何线索，或者反之。因此，实现是必须确保每次SA更新都进行一次新的DH交换。换句话说，发起方绝不能在DH形变中提议“NONE”，而响应方也绝不能接受“NONE”提议。这也意味着一次成功的IKE SA更新必然会包含KEi/KEr载荷。

新IKE SA必须将其消息计数重置为0。

SK_d，SK_ai, SK_ar, SK_ei和SK_er由SKEYSEED计算生成（参见2.14），使用新交换时的SPIi， SPIr， Ni和Nr，以及新SA的PRF。

### 2.19. 请求远端网络中的内部地址

在点到网关的部署场景当中，经常会遇到远端点需要获取安全网关内部网络地址的需求，并且该地址通常会动态分配。对于改临时地址的请求，可以通过在任意创建子SA的请求中附加CP载荷来完成。但是需要注意，通常在IKE_AUTH的交换中仅分配单个地址。该地址将持续使用直至IKE SA到期。

此项功能可以为访问被IPSec远程访问服务器（IRAS）保护网络的IPSec远程客户端（IRAC）提供地址分配。由于IKE_AUTH交换产生了一个IKE SA和一个子SA，IRAC必须在IKE_AUTH交换当中请求改IRAS管理的地址（以及其他涉及到受保护网络的信息）。IRAS则将从某些来源取得地址，例如DHCP/BOOTP服务器或其自定义的地址池。

   Initiator                         Responder
   -------------------------------------------------------------------
    HDR, SK {IDi, [CERT,]
       [CERTREQ,] [IDr,] AUTH,
       CP(CFG_REQUEST), SAi2,
       TSi, TSr}  -->
                                <--  HDR, SK {IDr, [CERT,] AUTH,
                                         CP(CFG_REPLY), SAr2,
                                         TSi, TSr}

在任何情况下，CP载荷必须置于SA载荷之前。在有多次IKE_AUTH的情况下，CP载荷必须置于和SA载荷相同的消息中。

CP(CFG_REQUEST)载荷必须至少包含一个INTERNAL_ADDRESS属性（IPv4或IPv6），但可以包含多个发起方希望的到响应的额外属性。

例如有以下发起方发出的消息：

   CP(CFG_REQUEST)=
     INTERNAL_ADDRESS()
   TSi = (0, 0-65535,0.0.0.0-255.255.255.255)
   TSr = (0, 0-65535,0.0.0.0-255.255.255.255)

注意：TS包含：协议，端口范围，地址范围。

响应方发出的消息：

   CP(CFG_REPLY)=
     INTERNAL_ADDRESS(192.0.2.202)
     INTERNAL_NETMASK(255.255.255.0)
     INTERNAL_SUBNET(192.0.2.0/255.255.255.0)
   TSi = (0, 0-65535,192.0.2.202-192.0.2.202)
   TSr = (0, 0-65535,192.0.2.0-192.0.2.255)

最终返回的值依赖于具体实现。而正如上例说是，IRAS可能将未在CP(CFG_REQUEST)载荷中生命的属性值返回给IRAC，并且可能忽略那些它并不支持的可选属性。

响应方不能在没有收到CP(CFG_REQUEST)的情况下直接回复CP(CFG_REPLY)，以避免IRAS在客户端并不能处理CP(CFG_REPLY)时进行不必要的配置查询。

如果IRAS的配置要求某IDi必须使用CP载荷，而IRAC并未成功发送CP(CFG_REQUEST)，IRAS必须将请求判为失败，并回复FAILED_CP_REQUIRE错误中止子SA的创建。FAILED_CP_REQUIRE错误并不会影响IKE SA的创建，而仅影响子SA。发起方可以通过稍后发起带有CP(CFG_REQUEST)载荷的消息修复该错误。FAILED_CP_REQUIRE错误中不附带任何数据。

### 2.20. 请求对等体的版本

当一IKE对等体希望获取对方的软件版本信息时，它可采用以下方式。下面是一个使用INFORMATIONAL交换携带配置请求消息的例子，它发生在IKE SA和第一个子SA都建立之后。

IKE实现可以在认证之前提供版本信息，若实现认为有安全风险也可在认证之后提供。在这种情况下，响应方必须在CP载荷中植入空字符串，若其不支持CP载荷亦可直接不在回复中放置CP载荷。

   Initiator                         Responder
   -------------------------------------------------------------------
   HDR, SK{CP(CFG_REQUEST)}  -->
                                <--  HDR, SK{CP(CFG_REPLY)}

   CP(CFG_REQUEST)=
     APPLICATION_VERSION("")

   CP(CFG_REPLY) APPLICATION_VERSION("foobar v1.3beta, (c) Foo Bar
     Inc.")

### 2.21. 错误处理

在IKE处理过程中会出现很多类型的错误。基本规则为，如果接收到的消息格式有问题，或者由于策略设置（例如加密算法不匹配），那么响应的消息中使用Notify负载指明错误。是否发送该响应取决于存不存在经过认证的IKE SA。

如果在解析或者处理回复报文时有问题，基本原则是不回复任何错误消息，因为响应方不应该擅自生成新的请求（而新请求时送回错误消息的唯一方式）。另外，这些处理错误应是的接收方重置IKE状态（例如发送Delete消息删除异常的SA）。

只有认证失败（AUTHENTICATION_FAILED和EAP协商失败）和畸形消息（INVALID_SYNTAX）才会导致直接删除IKE而无需使用明确的带有Delete载荷的INFORMATIONAL交换。其他错误情况如果配置了相应的策略，也可要求使用带有Delete载荷的INFORMATIONAL交换。如果时EAP协商失败导致的错误，无需发送AUTHENTICATION_FAILED通知。

#### 2.21.1. IKE_SA_INIT阶段的错误处理

在受加密保护的IKE SA建立之前的错误处理需要尤为小心。在使用错误信息以帮助对方诊断问题和避免由于伪造信息形成DoS直接需要有所取舍。在IKE_SA_INIT交换阶段，任何错误通知都将导致交换失败。要注意某些错误通知如COOKIE，INVALID_KE_PAYLOAD或INVALID_MAJOR_VERSION有可能导致后续成功的交换。因为所有此阶段的错误通知都是未经认证的，接收方在应该在决定放弃前的一定时间内尽可能处理。接收方不应在收到的错误信息立即反应，除非纠正机制已被定义，例如对于COOKIE，INVALID_KE_PAYLOAD和INVALID_MAJOR_VERSION错误的处理。

#### 2.21.2. IKE_AUTH阶段的错误处理

所有发生在IKE_AUTH交换阶段的错误都会导致认证失败，任意错误（如无效的共享秘密，无效的ID，不可信的证书签发者，已吊销或过期的证书等）都应该产生AUTHENTICATION_FAILED通知。如果是响应方的错误，通知消息将以受保护的形式响应，且该回复通常仅包含通知载荷。尽管IKE_AUTH消息时经过加密和完整性保护的，如果对等体接受改错误通知时还未完成对对方的认证，对等体应谨慎处理该信息。

如果是发起方的错误，错误通知可通过单独的INFORMATIONAL交换返回，通常不携带其他类型的载荷。这是不基于错误发起新交换的基本准则的一个例外情况。

注意，包含不支持类型的紧急载荷请求消息或者整个消息都为畸形（而非只是某一载荷畸形），接收方必须整体拒绝，而且必须使用UNSUPPORTED_CRITICAL_PAYLOAD或是INVALID_SYNTAX类型的通知消息作为回复。在这种情况下，接收方不应核实认证相关的载荷。

如果IKE_AUTH交换的认证成功了，IKE SA也就建立了；然而，子SA的建立或配置信息请求仍有可能失败。这种失败并不会导致IKE SA被自动删除。特别是响应方可能将所有认证相关载荷和错误通知（FAILED_CP_REQUIRED，FAILED_CP_REQUIRED等等）一起发送，这是发起方一定不能因为这些错误信息而将认证标记为失败。当然，发起方可以根据策略配置一定时间后将IKE SA删除。

在IKE_AUTH交换当中，或者在紧随其后的INFORMATIONAL交换（在处理IKE_AUTHIKE_AUTH响应发送错误的情况下）当中，只有UNSUPPORTED_CRITICAL_PAYLOAD，INVALID_SYNTAX和AUTHENTICATION_FAILED通知能够促使直接删除或不建立IKE SA，而无需Delete载荷。扩展文档可能对这些语义定义新的错误通知，但不能在对等体没有申明可以理解这些消息直接使用，跟使用Vendor ID载荷类似。

#### 2.21.3 IKE SA认证之后的错误处理

在IKE SA认证完成之后，所有对于错误的回复必须在响应中指明该错误。

在一般情况下，对等体发出的一个正常的响应不应该导致另一对等体产生错误，所以某一对等体不可能直接发送错误信息，而是只能在响应中包含错误。因为以INFORMATIONAL交换发出了错误消息可能会导致循环，这种类型的错误也不应该发送。如果错误消息表明该对等体没有跟另一对等体在相同状态，那么最好是双面都删除掉相关的IKE SA，随后重新协商。

如果对等体在解析某个请求的时候发现该请求的格式有问题（在该请求通过了验证码检查和窗口检查之后）并且回复了INVALID_SYNTAX通知，这种错误通知应被双方都归类为致命错误，也就是说相关的IKE SA必须直接被删除，而无需适用额外的Delete载荷。

#### 2.21.4. IKE SA之外的错误处理

对等体应当限制其对于未受保护消息的回复速率。

如果某对等体在UDP端口500/4500上收到了已知IKE SA场景之外的消息（且该消息并非用于建立新IKE SA的请求），这有可能是因为该对等体最近崩溃过。如果该消息属于回复类型，对等体可将其标记为可疑事件但绝不能回复。如果该消息属于请求类型，对等体将可将其标记为可疑事件并可以响应它。如果选择发送响应，该响应必须以和接收到消息相同的IKE SPI和消息ID发送给源IP和端口。该响应不能以加密保护，必须包含INVALID_IKE_SPI通知载荷。INVALID_IKE_SPI用以表明IKE消息的目的SPI无法被识别；这通常表明接收方重启过并已清楚之前维护的IKE SA信息。

对等体在收到未受保护的通知载荷时，不可对其进行响应也不可改变任何现有SA的状态。该消息可能是伪造消息也可能是某真通信方被骗而发出的。对等体应该将这种消息（还有类似ICMP目标不可达的网络消息）作为发现该IP相关SA有异常的提示，并应该对这些SA发现身存检测。实作也应该该类型检测的发送速率以免被欺骗而发起无意的DoS攻击。

如果有错误发正在IKE请求场景之外（比如对等体都到了本地未知SPI的ESP消息），对等体应该发送一个INFORMATIONAL交换并携带描述该错误的通知载荷。

当对等体收到来自某IP（和端口，如是NAT-T环境）的可疑消息，？？？该消息包含的IEK SA属于应该用INFORMATIONAL交换和IKE通知载荷发送通知的SA。接收方不能更改任何SA的状态，但可以对该事件进行审计以帮助诊断异常。

### 2.22. IPComp

对[IP-COMP]的使用可疑作为子SA协商的一部分进行。IP压缩会在每个数据包引入一个新的头部以及一个压缩参数索引（CPI），该虚拟的“压缩关联”依赖于包含它的ESP或AH SA。压缩关联在相应的ESP或AH SA消失后随之一起消失。它不需要额外的Delete载荷。

IP压缩的协商与子SA加密参数的协商是相互独立的。子SA协商的发起方可将其支持的一个或多个压缩算法通过一个或多个类型为IPCOMP_SUPPORTED的通知载荷发送给对方。该通知消息只被包含在带有协商子SA的SA载荷且使用发起方有在该子SA使用IPComp的意愿。响应方可能使用IPCOMP_SUPPORTED通知载荷指明其接受的某一算法以表示对该协商的接受。这些载荷不能出现在不包含SA载荷的消息当中。

该载荷关联数据部分包括一个16位的IPComp CPI，随后是8位的Transform ID，在之后是被该Transform ID定义长度和格式的可选属性。一个SA协商发起消息可能包含多个IPCOMP_SUPPORTED载荷以指明发起方支持的多个算法。而SA响应消息最多只能包含一个IPCOMP_SUPPORTED载荷。

Transfrom ID在以下列出。下表中的值仅在RFC 4306发表时列出。在其发表之后，可能会有新的值定义。读者应参考[IKEV2IANA]获取最新数据。

  Name              Number   Defined In
   -------------------------------------
   IPCOMP_OUI        1
   IPCOMP_DEFLATE    2        RFC 2394
   IPCOMP_LZS        3        RFC 2395
   IPCOMP_LZJH       4        RFC 3051

尽管有对于允许接受多个压缩算法并且在两个方向的子SA上使用不同算法的讨论，实作不能接受本没有提议的IPComp算法，不能接受多个算法，也不能使用不同于协商好的算法之外的算法对数据进行压缩。

将IPComp协商同加密算法协商独立开来的一个副作用就是，对于多个加密算法而言，对其中一些提议IPComp而对另外一些不提议是无法实现的。

在某些情况下，使用稳健头标压缩（ROHC）可能比IP压缩更合适。[ROHCV2]定义了在IKEv2和IPsec中使用ROHC的细节。

### 2.23. NAT穿越

网络地址转换（NAT）网关是有争议的一种实体。本节将简要描述它们是什么和它们如何影响IKE流量。很多人认为NAT是邪恶的而我们不应该在设计协议时考虑它们。IKEv2的确定义了一些不直观的处理规则使得NAT可以工作的更好。

NAT存在的主要原因是IPv4地址的短缺，应该还有些次要原因。处于NAT“之后”的IP节点的IP地址将不再是全球唯一的，而是被分配了在NAT之后的网关当中唯一的IP地址，而这些IP地址在其他NAT之后的网络当中可以复用。通常来说，NAT后的节点可以使用该唯一地址与处于同一NAT之后的节点通信，但不能使用该地址与其他NAT之后的节点通信。这些规则也有例外。当这些节点与处于Internet的节点通信时，NAT网关将IP源地址“转换”为一个可以路由回到网关的地址。从Internet发回给网关的数据包，其目的地址将会“转换为”内部地址以使得数据包可以最终路由到正确的节点。

NAT被设计为对端点透明。处于NAT之后节点和Internet上节点的软件通过NAT通信时无需做任何修改。某些协议在实现这种透明性的时候会有一些困难。在其数据段包含IP地址的协议再通过NAT网关时会出现问题，除非NAT网关能够理解这些协议并对这些数据段和IP头部一起进行修改。从根本上来说这些做法是不可靠的，违背了网络分层原理，并通常会导致一些后续问题。

通过NAT设备打开IPsec连接时会引入一些问题。如果连接使用的是传输模式，对于数据包中IP地址的转变会导致校验失败，并且由于数据加密的原因，NAT设备无法修改校验和。即使是隧道模式，也会有路由问题，因为对于AH和ESP数据包的地址转换需要特殊的逻辑，而该逻辑是启发式的而且不稳定。因为这些原因，IKEv2将使用UDP封装IKE和ESP保温。这种编码方式稍微损失的效率但使得NAT更容易处理。此外， 防火墙可被配置为允许UDP封装的IPsec流量通过，但不允许原始的未被封装的ESP/AH流量，抑或反之。

NAT当中对TCP和UDP的端口随地址一样进行转换很常见，并且还会根据端口号针对入方向的数据包影射给不同的内部节点。基于这个原因，尽管IKE数据包必须使用500或4500作为源目端口发送和接受，它们同时也需要被从任何端口接受并且回复也应发送给相同的端口和地址。这是因为端口信息可能会被网络当中的NAT设备修改。简单来说，IKE端点的IP地址通常不被包含在IKE载荷当中，因为这些载荷都是被加密保护的，而且无法被NAT透明的更改。

端口4500预留给被UDP封装的ESP和IKE流量。当IPsec端点发现它和对等地之间有NAT（细节见后文）时，它必须将所有后续的报文有从4500端口发送，NAT对这些流量（有可能使用端口500）不会作特殊处理.

发起方可以为IKE和ESP都是用4500，不管有没有NAT，即使是在IKE发起阶段。当某一方使用4500端口时，使用UDP封装ESP不是必要的，但是能够解析收到的UDP封装ESP数据包时必要的。一定不能使用端口500作为UDP封装。如果支持NAT穿越（NAT-T）（即在IKE_SA_INIT中交换了NAT_DETECTION_*_IP载荷），所有设备都应该在任何时候能接收和处理UDP封装的ESP报文和普通ESP报文。任一通信方都可决定是否为ESP使用UDP而不管对方的选择。但是，如果NAT被检测到了，双方都必须使用UDP封装ESP。

对于NAT穿越特性的要求[NATREQ]在后面列出。是否支持NAT-T是可选的。本节描述的要求对于选择支持NAT-T特性的实现是必须的。

+ IKE发起方和响应方都必须在IKE_SA_INIT报文中包含NAT_DETECTION_SOURCE_IP和NAT_DETECTION_DESTINATION_IP的通知载荷。这些载荷可用以检测在主机之间是否有NAT，哪一方在NAT之后。这些载荷在IKE_SA_INIT数据包中的位置紧随与Ni和Nr载荷之后（在可选的CERTREQ载荷之前）。

+ NAT_DETECTION_SOURCE_IP通知关联的数据为SPI（以他们在包头出现的顺序为序），原始源IP地址和源端口的SHA-1摘要。在发送方有多个地址关联而导致其无法预测所使用的具体地址时，有可能出现多个NAT_DETECTION_SOURCE_IP载荷。

+ NAT_DETECTION_DESTINATION_IP通知关联的数据位SPI（以他们在包头出现的顺序为序），原始目的IP和目的端口的SHA-1摘要。

+ NAT_DETECTION_SOURCE_IP或NAT_DETECTION_DESTINATION_IP通知的接收方可通过对比接收到的值和本地计算的SPI加源或目的地址，端口的SHA-1摘要，如果它们不匹配，则应该启用NAT穿越。如果发现本地计算的NAT_DETECTION_SOURCE_IP哈希和所有接收到的NAT_DETECTION_SOURCE_IP载荷均不匹配，接收方可以在NAT穿越功能未开启的情况下拒绝连接。而如果发现NAT_DETECTION_DESTINATION_IP不匹配， 则说明接受该载荷的系统处于NAT之后，那么该系统应该开始发送保活报文，如[UDPENCAPS]所说明；此外，它还可以在NAT穿越功能未开启的情况下拒绝连接。

+ 如果所有接收到的NAT_DETECTION_SOURCE_IP载荷与使用在IP包头中获取的值的计算结果不匹配，则说明发送载荷的系统处于NAT之后（即某路由设备更改了数据包的源地址）。在这种情况下，接收系统应该动态的更新对方低通的IP地址，如下文所示。

+ IKE发起方必须检测存在的NAT_DETECTION_SOURCE_IP或NAT_DETECTION_DESTINATION_IP载荷，如果发现不匹配的话，必须将相关SA所有后续的IKE和ESP报文通过UDP4500端口封装。

+ 使用UDP4500封装IKE报文时，IKE头部之前需填充32位零然后置于UDP头部之后。使用UDP4500封装ESP报文时，ESP报文直接置于UDP头部之后。由于ESP头部的32位字段包含的是SPI，而有效的SPI不可能为0，所有很容易区分UDP封装的IKE和ESP报文。

+ 即使没有NAT被检测到，实作也必须处理UDP封装的ESP报文。

+ 报文中的原始源目IP地址在传输模式中的TCP和UDP报文校验修正时需要的（细节见[UDPENCAPS]）,该信息可从交换时使用的流量选择器中获取。在传输模式的NAT-T情况下，流量选择器必须仅包含一个IP地址，就是原始IP地址。在2.23.1节中就更多细节。

+ 可能会出现NAT设备删除活跃端口映射的情况（例如，保活消息间隔太久，或是NAT设备重启）。对某主机而言，它可能会收到一个包，其完整性校验是通过的，但其端口或地址发生相较之前相关SA上验证过的数据包而言发生了变化。当接收到这种数据包的时候，对于不支持其他恢复机制如IKEv2 Mobility和Multihoming（MOBIKE）[MOBIKE]，并且不是在NAT之后的主机而言，它应该将后续所有的报文（包括重传的报文）发往该被验证报文的新地址和端口，并且应该将新地址端口保存为相关SA新的关联信息（即应动态的更新地址信息）。对于处于NAT之后的主机来说，这种对于收到带有新地址端口信息的被验证数据包而采取的动态更新行为应该被避免，因为这又可能带来DoS攻击（这将允许攻击者使用一个数据包即可破坏连接）。并且，该动态更新仅能作为新数据包回复；否侧的话，攻击者可能通过重放旧的数据包而导致地址的回退。基于此，只有在重放保护开启的情况下才允许使用动态更新。当IKEv2和MOBIKE一起使用时，上文描述的地址动态更新将于MOBIKE对于相同情况的恢复会有冲突。更多细节参见3.8节的[MOBIKE]。

#### 2.23.1. 传输模式下的NAT穿越

在传输模式下使用NAT-T需要对IKEv2的流量选择器作特殊处理。完整的场景为：

   +------+        +------+            +------+         +------+
   |Client| IP1    | NAT  | IPN1  IPN2 | NAT  |     IP2 |Server|
   |node  |<------>|  A   |<---------->|  B   |<------->|      |
   +------+        +------+            +------+         +------+

（其他场景均为此复杂场景的简化，故只讨论最复杂场景。）

此场景中，有两个NAT设备：NAT A和NAT B。NAT A为动态NAT映射将客户端源IP IP1映射为IPN1。NAT B是有静态NAT配置使得发往地址IPN2的数据包映射到VPN网关地址IP2。这使得客户端可以通过地址IPN2连接到服务器。NAT B不必非得是静态NAT，但客户端需要知道如何连接到服务器，而这就要求它必须知道NAT B的外部地址，也就是IPN2。如果NAT B是静态NAT，则其地址可以直接配置给客户端。另一种选择就是使用其他方式获取该地址（比如DNS），但这超出了IKEv2的讨论范畴。

在此场景中，客户端和服务器都配置为为客户端发往服务器的流量使用传输模式。

当客户端开始为发往服务器的流量创建IKEv2 SA和子SA时，可能会存在一个触发数据包，其源IP为IP1，目的IP为IPN2。其对等体认证数据库（PAD）和SPD需要有匹配这些IP的配置（或是包含该地址对的通配条目）。

因为是传输模式，客户端将在流量选择器和IKE报文的IP地址段使用相同的值。对于传输模式，TSi和TSr只能放置一个IP地址。如果有需要的话，客户端可以使用多个流量选择器，例如，有多个端口范围需要协商，但所有的TSi条目必须使用形如IP1-IP1的地址，而所有的TSr条目则必须使用形如IPN2-IPN2的地址。第一个流量选择器的TSi和TSr应该尽可能精确，包含协议和端口号，同触发请求的数据包保持一致。

NAT A会将IKE包中的源IP地址由IP1转换为IPN1，NAT B会将IKE包中的目的地址由IPN2转换为IP2，所以当数据包到达服务器的时候，它携带的流量选择器跟客户端发出时一致，但IKE包的IP地址已被替换成IPN1和IP2。

当服务器接收到这个数据包时，它通常会根据ID检查如RFC 4301[IPSECARCH]中描述的对等体授权数据库（PAD），然后基于流量选择器搜索SPD。因为IP1对于服务器而言没有任何意义（那是客户端在NAT之后的地址），在传输模式下若基于它进行查找是无用的。另外，服务器在找到匹配的SPD条目之前无法确认其策略是否允许传输模式。

在这种情况下，服务器应该先确认发起方请求了传输模式，然后对流量选择器做地址替换。它先要保存旧的TS IP地址以便后续用作校验和修复（TSi中的地址可作为原始源IP地址）。随后，如果对方被检测到位于NAT之后，服务器将TSi载荷中的IP替换为接收到的IKE包头中的源IP（即将TSi中的IP1替换为IPN1）。如果服务器端被检测到位于NAT之后，它将TSr载荷当中的IP替换为接收到的IKE包头中的目的IP（即将TSr中的IPN2替换为IP2）。

在完成地址替换之后，TS和IKE UDP报文的源/目地址将一致，而服务器将根据新的TS进行SPD查询。一旦由条目匹配并允许传输模式，该条目将被使用。如果找到的SPD不允许传输模式，那服务器可能撤销地址替换，并使用原始的TS重试SPD查找。如果第二次查找成功了，服务器将使用对端发送的真实TS创建隧道模式的SA。

传输模式中的地址替换是必须的，因为SPD查找使用的地址将被本地主机看到。这也保证了隧道的SAD条目检查能完成，而且回复的数据包被本地操作系统可见的地址添加。

最常见情况是，服务器时使用通配符条目匹配任何地址，但这也会制造不同的SPD条目，例如，用于不同的已知NAT外部地址。

在SPD查找完成之后，服务器将会进行更具匹配的SPD进行TS缩减。它会使用以及完成替换的TS，因此它在送回TS时使用IPN1和IP2作为地址；它仍能使用TS所见端口号和端口范围。为子SA创建的SAD将是使用服务器所见的地址，即IPN1和IP2。

当客户端收到服务器对子SA的回复时，它将实施类似的处理。如果传输模式SA被创建了，客户端可将收到的原始TS作为原始源和目的地址。它将替换TS中的IP为IKE包头中的IP地址：将IPN1替换为IP1，IP2替换为IPN2。然后，它将在回复TS之前使用这些TS验证SA，同时使用这些TS安装SAD条目。

概括传输模式下NAT-T的使用规则：

对于提议传输模式的客户端：

+ TSi必须使用单个IP地址，而且必须匹配IKE SA的源IP。

+ TSr必须使用单个IP地址，而且必须匹配IKE SA的目的IP。

+ 首个TSi和TSr组后应该尽可能精确，包含协议和端口号，同触发请求的数据包一致。

+ 可能有多个TSi和TSr条目。

+ 如果SA选用了传输模式（即服务器在回复中包含了USE_TRANSPORT_MODE通知）：

    + 将原始TS存为接收到的源和目的地址。

    + 如果服务器位于NAT之后，替换TSi中的IP为IKE SA的本地地址。

    + 在使用TS做其他处理之前先完成地址替换而非保存原始值。这包括验证TS是否被对端正确的缩小，SAD条目的创建等等。

对于提议传输模式客户端的响应方：

+ 将原始TS中的IP地址存为接收到的源和目的地址，这可用与可能出现的地址替换撤销，用做[UDPENCAPS]中提到的“真是源和目的IP”，也可用作TCP/UDP校验和修复。

+ 如果客户端位于NAT之后，替换TSi为IKE SA的远端地址。

+ 如果服务器位于NAT之后，替换TSr为IKE SA的本地地址。

+ 使用ID和替换后的TS完成PAD和SPD查找。

+ 如果未找到SPD条目或是找到的SPD条目不允许传输模式，这小TS替换。使用ID和原始TS重做PAD和SPD查找，此时也查找隧道模式的SPD条目（即回退到隧道模式）。

+ 但是，如果传输模式的SPD条目找到了，就使用替换后的TS和SPD条目做正常的TS缩减。然后使用得到的TS创建SAD条目和回复客户端。

### 2.24. 显式拥塞通知

当IPsec隧道如[IPSECARCH-OLD]在描述的工作时，ECN不太适合用于外层IP头，因为解封装处理会丢弃ECN中对于有问题网络的拥塞指示。基于IKEv1的IPsec隧道，其ECN的支持要求多种操作模式和协商（见[ECN]）。IKEv2简化了这种情况，它要求ECN可以使用在所有IKEv2创建的子SA的外层IP头部。特别的，所有创建的IKEv2的隧道模式，其封装和解封装必须支持[ECN]中指定的所有ECN功能属性，还必须实现[IPSECARCH]中指定的隧道封装和解封装流程以避免丢弃ECN拥塞指示。

### 2.25. 交换冲突

由于任何一方都可以发起IKEv2交换，就可能出现作用于同一SA的两个交换一定程度上重合了。这将导致双方的SA状态暂时不同步，而某一端会收到它无法按照正常流程处理的请求。

显然，使用大于1的窗口大小将会导致更复杂的情况，特别是处理请求时发生了乱序。本节集中讨论即使窗口为1的情况也会发生的问题，以及建议的解决方案。

当对等体由于暂时情况如正在更新密钥导致无法完成处理接收到的请求时应该发送一个TEMPORARY_FAILURE通知。而当对等体收到了TEMPORARY_FAILURE通知时，它绝不能立即重试操作；它必须等待以便使得发送方完成任何导致该临时状况的操作。接收方可以几分钟之内重试一次或多次请求。如果对等体在几分钟之内多次收到同意IKE SA上的TEMPORARY_FAILURE通知，它应该认为状态信息在两端失去了同步，进而关闭该IKE SA。

当对等体收到对于不存在的子SA的密钥更新请求时应该发送一个CHILD_SA_NOT_FOUND通知。发起方试图进行密钥更新的SA通过Notify载荷中的SPI字段指定，该字段是从REKEY_SA通知载荷中复制的。对等体在接收到CHILD_SA_NOT_FOUND通知时应该将该子SA直接删除（如果它还存在的话）然后再发送重新创建子SA的请求（如果子SA还不存在的话）。

#### 2.25.1 密钥更新或关闭子SA时的冲突

如果对等体收到了关于它正在删除的子SA的密钥更新请求，它应该回复TEMPORARY_FAILURE。如果对等体收到了关于它正在进行密钥更新的子SA的密钥更新请求，它应该照常回复，随后应该准备根据Nouces值删除其中一个重复的SA（见2.8.1）.如果对等体收到了关于本地不存在的子SA的密钥更新请求，它应该回复CHILD_SA_NOT_FOUND。

如果对等体收到了关于它正在删除的子SA的删除请求，它应该回复但不携带Delete载荷（见1.4.1）。如果对等体收到了关于它正在进行密钥更新的子SA的删除请求，它应该照常回复，携带Delete载荷。如果对等体收到了关于本地不存在的子SA的删除请求，它应该回复但不携带Delete载荷。

如果对等体收到了关于它正在进行密钥更新、正在创建或正在删除的其子SA的IKE SA密钥更新请求，它应该回复TEMPORARY_FAILURE。

#### 2.25.2 密钥更新或关闭IKE SA时的冲突

如果对等体收到了关于它正在进行密钥更新的IKE SA的密钥更新请求，它应该照常回复，随后应该准备根据Nouces值删除其中一个重复的SA并迁移被继承子SA（见2.8.2）。如果对等体收到了关于它正在删除的IKE SA的密钥更新请求，它应该回复TEMPORARY_FAILURE。

如果对等体收到了关于它正在进行密钥更新的IKE SA的删除请求，它应该照常回复并忘记自己的密钥更新请求。如果对等体收到了关于它正在删除的IKE SA的删除请求，它应该照常回复并忘记自己的删除请求。

如果对等体正在进行IKE SA的更新，而此时收到了创建或密钥更新子SA的请求，它应该回复TEMPORARY_FAILURE。如果对等体正在进行IKE SA的更新，而此时收到了删除子SA的请求，它应该照常回复，并发送Delete载荷。

## 3. 头部和载荷格式

本节的表格中，某些密码原语和配置属性标记为“UNSPECIFIED”。对于某些项目，目前没有已定义的规范所以不存在互操作性。未来某些规范可能描述这些用法，但在这些规范发布之前，在那些追求互操作性的实现当中，不应该使用被标记为的“UNSPECIFIED”项目。

### 3.1. IKE头部

IKE消息使用UDP端口500和/或4500，每个UDP数据报承载一个IKE消息。从数据包开始到UDP头部为止的内容在很大程度上是被忽略的，当然其中的IP地址和端口用作回包使用。当使用UDP端口500时，IKE消息紧跟着UDP头部。当使用UDP端口4500时，IKE消息前32位置0。这32位0并非IKE消息的一部分，也不算在IKE定义的任何长度或校验字段。每个IKE消息以IKE头部开始，本文以HDR指代。头部之后是一个或多个IKE载荷，每个载荷由前一载荷的“Next Payload”字段定义。载荷位于IKE消息中的顺序根据IKE头部的“Next Payload”的字段查找开始，随后的载荷由每个载荷中的“Next Payload”字段定义，最后的载荷其“Next Payload”字段填充0。如果某载荷类型是“Encrypted”的，该载荷将需要解密，而其内容将被解析位额外的载荷。Encrypted载荷必须是数据包中的最后一个载荷，而且不能包含另一个Encrypted载荷。

头部中响应方的SPI定义IKE SA的一个实例。这样就可以保证IKE的实例可以区分跟不同对等体建立的会话，甚至是同一对等体的不同会话。

所有整数表示的多字节字段以高位优先的顺序展开（即“高位字节优先”或“网络字节顺序”）。

IKE头部的格式如图4所示。

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       IKE SA Initiator's SPI                  |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       IKE SA Responder's SPI                  |
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Next Payload | MjVer | MnVer | Exchange Type |     Flags     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Message ID                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Length                             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Figure 4:  IKE Header Format

+ 发起方SPI（64位） - 发起方选择的标记某IKE SA的值。此值不能为0。

+ 响应方SPI（64位） - 响应方选择的标记某IKE SA的值。在IKE初始交换中（包括重传）的第一个消息中此值必须为0。

+ Next Payload（8位） - 指明紧跟头部之后的载荷的类型。每种载荷的格式和值后面将定义。

+ 主要版本（4位） - 指明正在使用的IKE协议的主要版本。基本本版本的实现必须将其设为2。基于IKE和ISAKMP之前版本的实现必须将其设为1。基于本版本的实现必须拒绝或忽略主要版本大于2的消息，并回复INVALID_MAJOR_VERSION通知，如2.5节所示。

+ 次要版本（4位） - 指明正在使用的IKE协议的次要版本。基本本版本的实现必须将其设为0。它们应忽略接收到的次要版本值。

+ 交换类型（8位）- 指明正在使用的交换类型。它将约束交换中每个消息内的载荷。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

      Exchange Type             Value
      ----------------------------------
      IKE_SA_INIT               34
      IKE_AUTH                  35
      CREATE_CHILD_SA           36
      INFORMATIONAL             37

+ 标志位（8位） - 指明为当前消息设置的特殊属性。生效的属性由标志位中的bit值决定。bit值有：

        +-+-+-+-+-+-+-+-+
        |X|X|R|V|I|X|X|X|
        +-+-+-+-+-+-+-+-+

根据下面的描述，某bit位被设置意味着其值是“1”，某bit位被清除意味着其值是“0”。“X”bit位在发送时必须清楚，而在接受时必须忽略。

    + R（Response） - 该bit位表明消息是对某具有相同ID消息的响应。该bit位在所有的请求消息中必须清除，而在所有的响应消息中必须设置。IKE端点不能针对标记为响应的消息进行回复（只有一个例外，见2.21.2）。

    + V（Version） - 该bit位表明发送方可以与比在主要版本字段声明的更高版本通信。IKEv2实现在发送消息时必须清除该位，在接收时必须忽略该位。

    + I（Initiator） - 该bit位在IKE SA的原始发起方发出的消息中必须设置，而在原始响应方发出的消息中必须清除。这可用户接收方来判断哪个64位SPI是由自己产生的。该bit变化将反映出谁发起了前一次IKE SA的密钥更新。

+ 消息ID（32字节，无符号整数） - 消息ID用于控制丢包重传和匹配请求与响应。在安全方面也至关重要，可用于防止重放攻击。参见2.1和2.2。

+ 长度（32字节，无符号整数） - 以8bit的个数表示整个消息的长度（头部+所有载荷）。

### 3.2. 通用载荷头部

每个有3.3至3.16定义的IKE载荷都已相同的通用载荷起始，如图5所示。后面所有的载荷图示都将包含该通用载荷头部，但为了简洁起见，每个字段的描述将略过。

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 5:  Generic Payload Header

通用载荷头部各字段定义如下：

+ 下一载荷（8位） - 消息中下一个载荷类型的标识。如果当前载荷时消息中的最后一个，该字段填充0。利用该字段，载荷可以在其后附加载荷同时设置“下一载荷”字段指明后续载荷的类型，从而实现“链式”结构。加密载荷，只能是消息的最后载荷，是唯一的例外。它以额外载荷的格式包含数据结构。在加密载荷的头部，其下一载荷设置为其包含的第一个载荷的类型，而非0；相反，它包含的最后一个载荷的下一载荷字段设置为0。载荷类型的值如下所列。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

      Next Payload Type                Notation  Value
      --------------------------------------------------
      No Next Payload                             0
      Security Association             SA         33
      Key Exchange                     KE         34
      Identification - Initiator       IDi        35
      Identification - Responder       IDr        36
      Certificate                      CERT       37
      Certificate Request              CERTREQ    38
      Authentication                   AUTH       39
      Nonce                            Ni, Nr     40
      Notify                           N          41
      Delete                           D          42
      Vendor ID                        V          43
      Traffic Selector - Initiator     TSi        44
      Traffic Selector - Responder     TSr        45
      Encrypted and Authenticated      SK         46
      Configuration                    CP         47
      Extensible Authentication        EAP        48

      （载荷类型值1-32将来不可使用，以保证与IKEv1的分配不冲突）

+ 紧急（1位） - 如果发送方希望接收方在不理解前一载荷的下一载荷字段值时而跳过当前载荷的处理时，应置0。如果发送方希望接收方在不理解千翼载荷的下一载荷字段时拒绝整个IKE消息，应置1。如果接收方能够理解载荷类型值，应该忽略该字段。对于本文定义的载荷类型，应置0。注意，紧急字段时应用在当前载荷的，而非又NP字段指明类型的下一载荷。之所以要求所有本文定义的载荷类型都将该字段置位0，是因为所有遵循本文的实现都必须理解本文定义的所有载荷类型，从而必须忽略该字段的值。跳过的载荷仍期有有效的下一载荷和长度字段。2.5就有更多的信息。

+ 保留（7位） - 必须置0；接收方必须忽略。

+ 载荷长度（18位，无符号整数） - 以8bit的个数表示的当前载荷的长度，包括通用载荷头部。

很多载荷都包含标记为“预留”的字段。IKEv2的某些载荷（和IKEv1的某些历史遗留）并不对齐32位边界。

### 3.3. 安全联盟载荷

安全联盟载荷，简称SA，用以协商SA的参数。SA载荷的组装需要特别注意。某一SA载荷可能包含多组提议。如果有不只一组提议的话，这些提议必须以优先级从高到低排列。每组提议包含一个单独的IPsec协议（IKE，ESP或AH），每种协议可能包含多种形变，而每种形变可能包含多个属性。解析SA时，实现必须检查全部载荷长度，它必须与载荷的内部长度和计数相匹配。提议，形变和属性都可以有其自己的可变长度的编码。它们是可嵌套的，使得SA的载荷长度将包含有SA、提议、形变和属性信息的组合内容。而形变的长度将包括它所包含的所有属性的长度。

SA、提议、形变以及属性的语法是基于ISAKMP；然后，语义上稍有不同。形成该复杂性和层次性的原因在于这样实现可以允许在三个SA中完成对多种算法组合的编码。有时会在多个算法中进行选择，有时可使用多种算法的组合。比如，发起方可能提议使用ESP，并使用（3DES与HMAC_MD5）或（AES与HMAC_SHA1）。

从ISAKMP和IKEv1更改语义的一个原因是为了是个在通常情况下编码更为紧凑。

提议的结构会在请其中包含一个提议数字和一个IPsec协议ID。每个结构包含的提议数字必须比前一个结构大1位数。在发起方SA载荷中的第一个提议必须使用数字1作为提议数字。使用多个提议的其中一个原因是为了可以同时提议标准模式加密套件和组合模式加密套件。组合模式的加密套件在单个加密算法中同时提供完整性和加密性保护，而且必须不提议完整性加密算法或值为“none”的单个完整性算法而同时不包含推荐的完整性算法。如果发起方想同时提议组合模式套件和普通套件，它必须包含两组提议：一种包含所有的组合模式套件，而另一种包含所有普通套件和完整性算法。例如，这种提议将包含两个提议结构。提议1是ESP，使用AES-28
，AES-192和AES-256的CBC（Ciper Block Chaining）模式，使用HMAC-SHA1-96或XCBC-96作为完整性算法；提议2使用AES-128或AES-256的GCM模式，伴随一个8个8bit的ICV（Interity Check Value）。两种提起都允许但不要求使用ESN（Extended Sequence Number）。这个例子可如下图描述：

   SA Payload
      |
      +--- Proposal #1 ( Proto ID = ESP(3), SPI size = 4,
      |     |            7 transforms,      SPI = 0x052357bb )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 128 )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 192 )
      |     |
      |     +-- Transform ENCR ( Name = ENCR_AES_CBC )
      |     |     +-- Attribute ( Key Length = 256 )
      |     |
      |     +-- Transform INTEG ( Name = AUTH_HMAC_SHA1_96 )
      |     +-- Transform INTEG ( Name = AUTH_AES_XCBC_96 )
      |     +-- Transform ESN ( Name = ESNs )
      |     +-- Transform ESN ( Name = No ESNs )
      |
      +--- Proposal #2 ( Proto ID = ESP(3), SPI size = 4,
            |            4 transforms,      SPI = 0x35a1d6f2 )
            |
            +-- Transform ENCR ( Name = AES-GCM with a 8 octet ICV )
            |     +-- Attribute ( Key Length = 128 )
            |
            +-- Transform ENCR ( Name = AES-GCM with a 8 octet ICV )
            |     +-- Attribute ( Key Length = 256 )
            |
            +-- Transform ESN ( Name = ESNs )
            +-- Transform ESN ( Name = No ESNs )

每个提议/协议结构之后紧跟着另一个或多个形变结构。而不同形变的数量通常由协议决定。AH有两个形变：ESN（Extended Sequence Numbers）和完整性检查算法。IKE通常有四个形变：一个DH组，一个完整性检查算法，一个PRF算法和一个加密算法。对于每一种协议，其所容许的形变将被分配一个形变ID数字，位于每个形变的头部。

如果多个形变属于同一个形变类型，提议中的这些形变之间是或的关系。如果多个形变属于不同的形变类型，形变直接的关系为与。例如，如果想提议ESP并使用(3DES或AES-CBC)和(HMAC_MD5或HMAC_SHA)，该ESP提议将包含两个类型为1的候选形变（一个是3DES，一个是AES-CBC），还有两个类型为3的候选形变（一个为HAMC_MD5，一个是HMAC_SHA）。这将最终产生4种提议组合。如果发起方仅想提议这些组合的子集，如(3DES和HMAC_MD5)或(IDEA和HMAC_SHA)，这将无法实现，因为无法将多个形变编码进单个形变。发起方需要生成两个不同的提议，每个提议包含两个形变。

某一形变可能包含一个或多个属性。当形变可以以多种形式使用时，属性是必要的，比如一个加密算法可以有不同的密钥长度。形变将指明算法而属性将指明密钥长度。大部分的形变是没有属性的。一个形变不能使用多个相同类型的属性。如果要提议某一属性的候选值（比如AES算法的不同密钥长度），实现必须使用多个相同类型的形变，每个形变包含一个属性。

形变和属性在本文的语义与IKEv1有显著区别。在IKEv1当中，如需要为某一协议携带多种算法，会将其中一个算法置于形变当中而其余的置于属性当中。

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Next Payload  |C|  RESERVED   |         Payload Length        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                          <Proposals>                          ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 6:  Security Association Payload

+ 提议（多个） - 一个或多个提议结构。

SA载荷的载荷类型为33。

#### 3.3.1. 提议子结构

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 0 (last) or 2 |   RESERVED    |         Proposal Length       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Proposal Num  |  Protocol ID  |    SPI Size   |Num  Transforms|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   ~                        SPI (variable)                         ~
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                        <Transforms>                           ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 7:  Proposal Substructure

+ 0（最后）或2（更多）（1个8bit） - 指明该提议子结构是否为SA中的最后一个。该语法继承自ISAKMP，但其实是不必要的，因为最后的提议可由SA长度确定。值2对应着IKEv1中的提议载荷类型，而提议结构中的前4个8bit被设计为类似于载荷的头部。

+ 保留（1个8bit） - 必须置为0；接收方必须忽略。

+ 提议长度（2个8bit，无符号整数） - 该提议的长度，包含所有形变和属性。

+ 提议数字（1个8bit） - 提议时，SA载荷中的第一个提议其提议数字应为1，后续的提议必须比之前的大于1（表明两个提议直接的或关系）。当某一提议被接受时，响应报文中的SA载荷的提议数字应与接受的提议数字一致。

+ 协议ID（1个8bit） - 指明当前协商使用的IPsec协议类型。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

      Protocol                Protocol ID
      -----------------------------------
      IKE                     1
      AH                      2
      ESP                     3

+ SPI大小（1个8bit） - 对于IKE SA协商起始阶段，该字段必须为0；SPI从外层头部获取。对于后续的协商，它与相关协议的SPI尺寸匹配（IKE为8，ESP和AH为4），以8bit的个数计数。

+ 形变数量（1个8bit） - 指明该提议中形变的数量。

+ SPI（可变长度） - 发送方的SPI。即使SPI的尺寸不是4个8bit的倍数，该字段也不会进行填充。在SPI大小字段值为0时，该字段将不会出现。

+ 形变（可变长度） - 一个或多个形变结构。

#### 3.3.2. 形变子结构

                        1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | 0 (last) or 3 |   RESERVED    |        Transform Length       |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Transform Type |   RESERVED    |          Transform ID         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   ~                      Transform Attributes                     ~
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            Figure 8:  Transform Substructure

+ 0（最后）或3（更多）（1个8bit） - 指明该形变是否为提议中的最后一个子结构。该语法继承自ISAKMP，但其实是不必要的，因为最后的提议可由提议的长度确定。值3对应着IKEv1中的形变类型，而形变结构中的前4个8bit被设计为类似于载荷的头部。

+ 保留 - 必须置为0；接收方必须忽略。

+ 形变长度 - 以8bit个数表示的形变子结构长度，包括头部和属性。

+ 形变类型（1个8bit） - 该形变结构中形变所属的类型。不同的协议支持不同的形变类型。对于某些提议，其中某些形变为可选的。如果某个形变时可选的，而发起方想要提议忽略该形变，则提议中见不包含该相应的形变类型。如果发起方希望使得该形变对于接收方为可选的，它应包含该形变子结构，并将形变ID=0置于属性。

+ 形变ID（2个8bit） - 形变类型中指定的实例。

形变类型下文列出。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

   Description                     Trans.  Used In
                                   Type
   ------------------------------------------------------------------
   Encryption Algorithm (ENCR)     1       IKE and ESP
   Pseudorandom Function (PRF)     2       IKE
   Integrity Algorithm (INTEG)     3       IKE*, AH, optional in ESP
   Diffie-Hellman group (D-H)      4       IKE, optional in AH & ESP
   Extended Sequence Numbers (ESN) 5       AH and ESP

（*）对本文指定的加密载荷强制进行完整性算法协商。比如，[AEAD] 基于已认证的加密定义了额外的格式，这当中的独立完整性算法将可以省略。

对于形变类型1（加密算法），其形变ID如下。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

   Name                 Number      Defined In
   ---------------------------------------------------
   ENCR_DES_IV64        1           (UNSPECIFIED)
   ENCR_DES             2           (RFC2405), [DES]
   ENCR_3DES            3           (RFC2451)
   ENCR_RC5             4           (RFC2451)
   ENCR_IDEA            5           (RFC2451), [IDEA]
   ENCR_CAST            6           (RFC2451)
   ENCR_BLOWFISH        7           (RFC2451)
   ENCR_3IDEA           8           (UNSPECIFIED)
   ENCR_DES_IV32        9           (UNSPECIFIED)
   ENCR_NULL            11          (RFC2410)
   ENCR_AES_CBC         12          (RFC3602)
   ENCR_AES_CTR         13          (RFC3686)

对于形变类型2（伪随机函数），其形变ID如下。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

   Name                        Number    Defined In
   ------------------------------------------------------
   PRF_HMAC_MD5                1         (RFC2104), [MD5]
   PRF_HMAC_SHA1               2         (RFC2104), [SHA]
   PRF_HMAC_TIGER              3         (UNSPECIFIED)

对于形变类型3（完整性算法）,其形变ID如下。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

   Name                 Number   Defined In
   ----------------------------------------
   NONE                 0
   AUTH_HMAC_MD5_96     1        (RFC2403)
   AUTH_HMAC_SHA1_96    2        (RFC2404)
   AUTH_DES_MAC         3        (UNSPECIFIED)
   AUTH_KPDK_MD5        4        (UNSPECIFIED)
   AUTH_AES_XCBC_96     5        (RFC3566)

对于形变类型4（DH组），其形变ID如下。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

   Name               Number     Defined In
   ----------------------------------------
   NONE               0
   768-bit MODP       1          Appendix B
   1024-bit MODP      2          Appendix B
   1536-bit MODP      5          [ADDGROUP]
   2048-bit MODP      14         [ADDGROUP]
   3072-bit MODP      15         [ADDGROUP]
   4096-bit MODP      16         [ADDGROUP]
   6144-bit MODP      17         [ADDGROUP]
   8192-bit MODP      18         [ADDGROUP]

尽管ESP和AH不会直接使用DH交换，但DH组依然可能在创建子SA是协商。这将允许对等体在CREATE_CHILD_SA交换时使用DH组，以此为新建的子SA密钥提供完美前向安全。

对于形变类型5（ESN），其形变ID如下。下表列出的值是RFC 4306发表之日的当前值。本文发布之后可能会出现新的值。读者应参考[IKEV2IANA]获取最新值。

   Name                               Number
   --------------------------------------------
   No Extended Sequence Numbers       0
   Extended Sequence Numbers          1

注意，支持ESN的发起方通常会使用两种ESN形变，一个类型为0，一个类型为1。如果提议中置包含ID为1的ESN形变，则说明发起方不支持普通（非扩展的）序列号。

在RFC 4306发布之后，有数种新的形变类型被定义。请参考IANA IKEv2获取详情。

#### 3.3.3. 协议可用形变类型

SA载荷中形变的数量和类型根据SA中的协议类型不同而相互独立。用于发起协商的SA载荷有以下强制和可选的形变类型。兼容的实现必须理解其支持协议的所有强制和可选类型（尽管其不需要接受包含不接受套件的提议）。如果接收方只接受NONE值，则相关的可选类型可忽略。

  Protocol    Mandatory Types          Optional Types
   ---------------------------------------------------
   IKE         ENCR, PRF, INTEG*, D-H
   ESP         ENCR, ESN                INTEG, D-H
   AH          INTEG, ESN               D-H

+ 对本文描述的加密载荷格式，完整性算法的协商是强制的。比如，[AEAD]描述了基于验证加密的额外格式，其中不协商完整性算法。

#### 3.3.4. 强制形变ID

为了互操作性而必须和应该支持的套件规范在本文中被移除，因为它们很有可能变化地比本文的演进更快。在本文发布时，这些套件在[RFC4307]中定义，之后可能有更新，亦或是有其他RFC定义新的套件。

从IKEv1学到的一个重要教训就是，一个系统不应该只实施强制算法并期望其成为所有用户的最佳选择。

IANA很可能在将来添加新的形变，而某些用户甚至想使用私有套件，特别是IKE，实现因该有能力支持不同的参数，限制于特定大小。为了达成这一目标，所有IKEv2实现应该包含一个管理组件，其可以允许指定（由用户或者系统管理员）新DH组的参数（生成器，模数和指数长度及值）。实现应该提供一个管理接口，通过该接口可以输入这些参数和相关的形变ID（由用户或系统管理员指定），已提供协商这些新组的功能。

所有IKEv2实现必须包含一个